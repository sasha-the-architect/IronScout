generator client {
  provider        = "prisma-client-js"
  output          = "./generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model admin_audit_logs {
  id          String   @id @default(cuid())
  adminUserId String
  merchantId  String?
  action      String
  resource    String?
  resourceId  String?
  oldValue    Json?
  newValue    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([action])
  @@index([adminUserId])
  @@index([createdAt])
  @@index([merchantId])
}

// DELETED: advertisements model (orphaned v1 placeholder, removed 2026-01-12)

model affiliate_feed_run_errors {
  id                  String              @id @default(cuid())
  runId               String
  code                String
  message             String
  rowNumber           Int?
  sample              Json?
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model affiliate_feed_runs {
  id                   String                  @id @default(cuid())
  feedId               String
  sourceId             String
  trigger              AffiliateFeedRunTrigger @default(SCHEDULED)
  status               AffiliateFeedRunStatus  @default(RUNNING)
  startedAt            DateTime                @default(now())
  finishedAt           DateTime?
  durationMs           Int?
  downloadBytes        BigInt?
  rowsRead             Int?
  rowsParsed           Int?
  productsUpserted     Int?
  pricesWritten        Int?
  productsPromoted     Int?
  errorCount           Int?
  productsExpired      Int?
  productsRejected     Int?
  duplicateKeyCount    Int?
  urlHashFallbackCount Int?
  activeCountBefore    Int?
  seenSuccessCount     Int?
  wouldExpireCount     Int?
  skippedReason        String?
  failureKind          String?
  failureCode          String?
  failureMessage       String?
  isPartial            Boolean                 @default(false)
  expiryStepFailed     Boolean                 @default(false)
  expiryBlocked        Boolean                 @default(false)
  expiryBlockedReason  String?
  expiryApprovedAt     DateTime?
  expiryApprovedBy     String?
  artifactUrl          String?
  correlationId        String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  affiliate_feed_run_errors affiliate_feed_run_errors[]
  affiliate_feeds           affiliate_feeds             @relation(fields: [feedId], references: [id], onDelete: Cascade)
  prices                    prices[]
  source_product_seen       source_product_seen[]

  @@index([feedId, startedAt])
  @@index([feedId, status, startedAt])
  @@index([feedId, trigger, startedAt])
  @@index([ignoredAt])
}

model affiliate_feeds {
  id                     String                @id @default(cuid())
  sourceId               String
  variant                FeedVariant           @default(FULL)
  network                AffiliateNetwork
  status                 AffiliateFeedStatus   @default(DRAFT)
  scheduleFrequencyHours Int?
  nextRunAt              DateTime?
  expiryHours            Int                   @default(48)
  consecutiveFailures    Int                   @default(0)
  lastRunAt              DateTime?
  manualRunPending       Boolean               @default(false)
  transport              FeedTransport         @default(SFTP)
  host                   String?
  port                   Int?
  path                   String?
  username               String?
  secretCiphertext       Bytes?
  secretKeyId            String?
  secretVersion          Int                   @default(1)
  format                 FeedFormat            @default(CSV)
  compression            FeedCompression       @default(NONE)
  lastRemoteMtime        DateTime?
  lastRemoteSize         BigInt?
  lastContentHash        String?
  maxFileSizeBytes       BigInt?
  maxRowCount            Int?
  feedLockId             BigInt                @unique @default(autoincrement())
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  createdBy              String?
  affiliate_feed_runs    affiliate_feed_runs[]
  sources                sources               @relation(fields: [sourceId], references: [id])
  // REMOVED: @@index([sourceId]) - redundant, covered by unique([sourceId, variant])

  @@unique([sourceId, variant])
  @@index([nextRunAt])
  @@index([status])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model alerts {
  id              String         @id @default(cuid())
  userId          String
  productId       String
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  watchlistItemId String?
  ruleType        AlertRuleType?
  isEnabled       Boolean        @default(true)

  /// ADR-015: Alert suppression for retroactive correction handling
  /// When set, alert is hidden in UI and never re-fired
  suppressedAt     DateTime?
  /// Who suppressed the alert (admin user ID or 'system')
  suppressedBy     String?
  /// Reason for suppression (e.g., 'run_ignored', 'correction_applied')
  suppressedReason String?

  products        products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users           users            @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items? @relation(fields: [watchlistItemId], references: [id], onDelete: Cascade)

  @@unique([userId, productId, ruleType], map: "alerts_userid_productid_ruletype_key")
  @@index([productId])
  // REMOVED: @@index([userId]) - redundant, covered by unique([userId, productId, ruleType])
  @@index([suppressedAt])
  @@index([watchlistItemId])
}

// DELETED: benchmarks model (benchmark subsystem removed for v1)
// DELETED: canonical_skus model (benchmark subsystem removed for v1)

model click_events {
  id              String   @id @default(cuid())
  clickId         String   @unique @default(cuid()) // Passed as affiliate subId for conversion tracking
  retailerId      String // Which retailer clicked to
  sourceId        String? // Which affiliate source
  sourceProductId String? // Which product listing was clicked
  sessionId       String?
  userAgent       String?
  ipHash          String?
  referrer        String?
  targetUrl       String? // Final affiliate URL clicked
  createdAt       DateTime @default(now())

  // Relations
  retailers       retailers        @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  sources         sources?         @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  source_products source_products? @relation(fields: [sourceProductId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([retailerId])
  @@index([sessionId])
  // REMOVED: @@index([clickId]) - redundant, field has @unique constraint
  @@index([sourceId])
  @@index([sourceProductId])
}

model data_subscriptions {
  id        String             @id @default(cuid())
  userId    String
  plan      DaaSPlan           @default(BASIC)
  status    SubscriptionStatus @default(ACTIVE)
  apiKey    String             @unique
  rateLimit Int                @default(1000)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  users     users              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model merchant_contacts {
  id                 String                @id @default(cuid())
  merchantId         String
  firstName          String
  lastName           String
  email              String
  phone              String?
  marketingOptIn     Boolean               @default(false)
  communicationOptIn Boolean               @default(true)
  isAccountOwner     Boolean               @default(false)
  isActive           Boolean               @default(true)
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  roles              MerchantContactRole[] @default([])
  merchants          merchants             @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, email])
  // REMOVED: @@index([merchantId]) - redundant, covered by unique([merchantId, email])
  @@index([email])
}

model retailer_feed_runs {
  id               String        @id @default(cuid())
  retailerId       String
  feedId           String
  status           FeedRunStatus
  errors           Json?
  rowCount         Int           @default(0)
  duration         Int?
  startedAt        DateTime      @default(now())
  completedAt      DateTime?
  primaryErrorCode String?
  quarantinedCount Int           @default(0)
  coercionCount    Int           @default(0)
  errorCodes       Json?
  indexedCount     Int           @default(0)
  rejectedCount    Int           @default(0)
  matchedCount     Int           @default(0)

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  retailer_feeds retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
  @@index([ignoredAt])
}

model retailer_feed_test_runs {
  id               String         @id @default(cuid())
  retailerId       String
  feedId           String
  sampleSize       Int            @default(50)
  status           TestRunStatus
  recordsParsed    Int            @default(0)
  wouldIndex       Int            @default(0)
  wouldQuarantine  Int            @default(0)
  wouldReject      Int            @default(0)
  warningCount     Int            @default(0)
  errorCount       Int            @default(0)
  primaryErrorCode String?
  errorSamples     Json?
  coercionSummary  Json?
  duration         Int?
  startedAt        DateTime       @default(now())
  completedAt      DateTime?
  retailer_feeds   retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
}

model retailer_feeds {
  id                      String                    @id @default(cuid())
  retailerId              String
  name                    String?
  url                     String?
  username                String?
  password                String?
  scheduleMinutes         Int                       @default(60)
  status                  FeedStatus                @default(PENDING)
  feedHash                String?
  lastSuccessAt           DateTime?
  lastFailureAt           DateTime?
  lastError               String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  accessType              FeedAccessType            @default(URL)
  enabled                 Boolean                   @default(true)
  formatType              FeedFormatType            @default(GENERIC)
  lastRunAt               DateTime?
  primaryErrorCode        String?
  retailer_feed_runs      retailer_feed_runs[]
  retailer_feed_test_runs retailer_feed_test_runs[]
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_skus           retailer_skus[]
  feed_corrections        feed_corrections[]

  @@index([retailerId])
  @@index([enabled])
}

// DELETED: merchant_insights model (benchmark subsystem removed for v1)

model merchant_invites {
  id             String           @id @default(cuid())
  merchantId     String
  email          String
  role           MerchantUserRole @default(MEMBER)
  inviteToken    String           @unique
  invitedById    String
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime         @default(now())
  merchants      merchants        @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_users merchant_users   @relation(fields: [invitedById], references: [id])
  // REMOVED: @@index([merchantId]) - redundant, covered by unique([merchantId, email])
  // REMOVED: @@index([inviteToken]) - redundant, field has @unique constraint

  @@unique([merchantId, email])
}

model merchant_notification_prefs {
  id                 String    @id @default(cuid())
  merchantId         String    @unique
  fatalFeedErrors    Boolean   @default(true)
  nonFatalFeedIssues Boolean   @default(false)
  successfulUpdates  Boolean   @default(false)
  weeklyPulse        Boolean   @default(true)
  insightAlerts      Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  merchants          merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}

model retailer_skus {
  id               String          @id @default(cuid())
  retailerId       String
  feedId           String?
  feedRunId        String?
  rawTitle         String
  rawDescription   String?
  rawPrice         Decimal         @db.Decimal(10, 2)
  rawUpc           String?
  rawSku           String?
  rawCaliber       String?
  rawGrain         String?
  rawCase          String?
  rawBulletType    String?
  rawBrand         String?
  rawPackSize      Int?
  rawInStock       Boolean         @default(true)
  rawUrl           String?
  rawImageUrl      String?
  parsedCaliber    String?
  parsedGrain      Int?
  parsedPackSize   Int?
  parsedBulletType String?
  parsedBrand      String?
  parseConfidence  Decimal?        @db.Decimal(3, 2)
  retailerSkuHash  String?
  contentHash      String? // Hash of mutable fields for change detection
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  lastSeenAt       DateTime?       @default(now())
  missingCount     Int             @default(0)
  productType      String?
  coercionsApplied Json?
  retailers        retailers       @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_feeds   retailer_feeds? @relation(fields: [feedId], references: [id])
  prices           prices[] // PR #2: Unified price history for retailer SKUs

  @@unique([retailerId, retailerSkuHash])
  // REMOVED: @@index([retailerId]) - redundant, covered by unique([retailerId, retailerSkuHash])
  @@index([feedId])
  @@index([isActive])
}

model merchant_users {
  id                      String                    @id @default(cuid())
  merchantId              String
  email                   String
  passwordHash            String
  name                    String
  role                    MerchantUserRole          @default(MEMBER)
  emailVerified           Boolean                   @default(false)
  verifyToken             String?
  resetToken              String?
  resetTokenExp           DateTime?
  lastLoginAt             DateTime?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  merchant_invites        merchant_invites[]
  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, email])
  // REMOVED: @@index([merchantId]) - redundant, covered by unique([merchantId, email])
  @@index([email])
}

model merchants {
  id                          String                       @id @default(cuid())
  businessName                String
  websiteUrl                  String
  phone                       String?
  storeType                   StoreType                    @default(ONLINE_ONLY)
  status                      MerchantStatus               @default(PENDING)
  tier                        MerchantTier                 @default(FOUNDING)
  pixelApiKey                 String?                      @unique
  pixelEnabled                Boolean                      @default(false)
  shippingType                ShippingType                 @default(UNKNOWN)
  shippingFlat                Decimal?                     @db.Decimal(10, 2)
  shippingPerUnit             Decimal?                     @db.Decimal(10, 2)
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  contactFirstName            String
  contactLastName             String
  lastSubscriptionNotifyAt    DateTime?
  subscriptionExpiresAt       DateTime?
  subscriptionGraceDays       Int                          @default(7)
  subscriptionStatus          MerchantSubscriptionStatus   @default(ACTIVE)
  autoRenew                   Boolean                      @default(true)
  paymentMethod               MerchantPaymentMethod?
  stripeCustomerId            String?                      @unique
  stripeSubscriptionId        String?                      @unique
  merchant_contacts           merchant_contacts[]
  merchant_invites            merchant_invites[]
  merchant_notification_prefs merchant_notification_prefs?
  merchant_users              merchant_users[]
  pixel_events                pixel_events[]
  merchant_retailers          merchant_retailers[]
  prices                      prices[]
}

/// Explicit Merchant↔Retailer relationship.
/// Per Merchant-and-Retailer-Reference: One Merchant can administer many Retailers.
/// This replaces the deprecated retailers.merchantId optional field.
/// Merchant-Retailer relationship. One Merchant can have many Retailers, one Retailer can have many Merchants.
/// The @@unique([merchantId, retailerId]) constraint prevents duplicate relationships.
model merchant_retailers {
  id         String                 @id @default(cuid())
  merchantId String
  retailerId String
  /// Status of the merchant-retailer relationship
  status     MerchantRetailerStatus @default(ACTIVE)
  createdAt  DateTime               @default(now())
  createdBy  String?
  updatedAt  DateTime               @updatedAt

  /// Listing status for consumer visibility (paid entitlement).
  /// Consumer visibility = retailers.visibilityStatus=ELIGIBLE AND listingStatus=LISTED AND status=ACTIVE
  listingStatus  MerchantRetailerListingStatus @default(UNLISTED)
  /// When retailer was listed (paid entitlement activated)
  listedAt       DateTime?
  /// Who listed the retailer (admin user ID or 'system' for auto)
  listedBy       String?
  /// When retailer was unlisted
  unlistedAt     DateTime?
  /// Who unlisted the retailer
  unlistedBy     String?
  /// Reason for unlisting (billing_delinquent, manual, policy_violation, etc.)
  unlistedReason String?

  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, retailerId])
  // REMOVED: @@index([merchantId]) - redundant, covered by unique([merchantId, retailerId])
  @@index([retailerId])
  @@index([status])
  @@index([listingStatus])
}

/// Per-retailer permissions for merchant users.
/// Per Merchant-and-Retailer-Reference: Permissions are per Retailer, explicit and auditable.
model merchant_user_retailers {
  id                 String               @id @default(cuid())
  merchantUserId     String
  merchantRetailerId String
  /// Role for this user on this specific retailer
  role               MerchantRetailerRole @default(VIEWER)
  createdAt          DateTime             @default(now())
  createdBy          String?
  updatedAt          DateTime             @updatedAt

  merchant_users     merchant_users     @relation(fields: [merchantUserId], references: [id], onDelete: Cascade)
  merchant_retailers merchant_retailers @relation(fields: [merchantRetailerId], references: [id], onDelete: Cascade)

  @@unique([merchantUserId, merchantRetailerId])
  // REMOVED: @@index([merchantUserId]) - redundant, covered by unique([merchantUserId, merchantRetailerId])
  @@index([merchantRetailerId])
}

model execution_logs {
  id          String     @id @default(cuid())
  executionId String
  level       LogLevel   @default(INFO)
  event       String
  message     String
  metadata    Json?
  timestamp   DateTime   @default(now())
  executions  executions @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([event])
  @@index([executionId])
  @@index([level])
}

model executions {
  id            String          @id @default(cuid())
  sourceId      String
  status        ExecutionStatus @default(PENDING)
  startedAt     DateTime        @default(now())
  completedAt   DateTime?
  duration      Int?
  itemsFound    Int             @default(0)
  itemsUpserted Int             @default(0)
  errorMessage  String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_scrape_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  execution_logs execution_logs[]
  sources        sources          @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([ignoredAt])
}

model feed_corrections {
  id                  String               @id @default(cuid())
  retailerId          String
  feedId              String
  quarantinedRecordId String?
  recordRef           String
  field               String
  oldValue            String?
  newValue            String
  createdBy           String
  createdAt           DateTime             @default(now())
  retailer_feeds      retailer_feeds       @relation(fields: [feedId], references: [id], onDelete: Cascade)
  quarantined_records quarantined_records? @relation(fields: [quarantinedRecordId], references: [id])

  @@index([retailerId])
  @@index([feedId, recordRef])
  @@index([quarantinedRecordId])
}

// DELETED: market_reports model (orphaned v1 placeholder, removed 2026-01-12)

model pixel_events {
  id            String    @id @default(cuid())
  merchantId    String
  orderId       String
  orderValue    Decimal   @db.Decimal(10, 2)
  orderCurrency String    @default("USD")
  skuList       Json?
  clickEventId  String?
  attributedAt  DateTime?
  userAgent     String?
  ipHash        String?
  referrer      String?
  createdAt     DateTime  @default(now())
  merchants     merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([merchantId])
  @@index([orderId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// Per ADR-015: Price history is append-only. Provenance fields enable corrections.
/// PR #2: Unified prices table supports both canonical products AND retailer SKUs.
/// - productId: Set when linked to canonical product (affiliate/crawl pipelines)
/// - retailerSkuId: Set when linked to retailer SKU (retailer pipeline)
/// - Both can be null initially; linked later via resolver
model prices {
  id                  String     @id @default(cuid())
  productId           String?
  retailerId          String
  merchantId          String?
  sourceId            String?
  retailerSkuId       String? // PR #2: Link to retailer_skus for unified price history
  price               Decimal    @db.Decimal(10, 2)
  currency            String     @default("USD")
  url                 String
  inStock             Boolean    @default(true)
  createdAt           DateTime   @default(now())
  /// ADR-015: When the price was observed at the source (not when written to DB)
  /// This is the canonical timestamp for correction matching and provenance
  observedAt          DateTime   @default(now())
  freeShippingMinimum Decimal?   @db.Decimal(10, 2)
  shippingCost        Decimal?   @db.Decimal(10, 2)
  shippingNotes       String?
  originalPrice       Decimal?   @db.Decimal(10, 2)
  priceType           PriceType?
  saleStartsAt        DateTime?
  saleEndsAt          DateTime?
  affiliateFeedRunId  String?
  priceSignatureHash  String?
  sourceProductId     String?

  /// ADR-015 Provenance: Type of ingestion run that created this price
  ingestionRunType IngestionRunType?
  /// ADR-015 Provenance: ID of the specific run (execution, affiliate_feed_run, retailer_feed_run)
  ingestionRunId   String?
  /// ADR-015 Provenance: Affiliate network ID if from affiliate feed
  affiliateId      String?

  affiliate_feed_runs affiliate_feed_runs? @relation(fields: [affiliateFeedRunId], references: [id])
  products            products?            @relation(fields: [productId], references: [id], onDelete: Cascade)
  retailers           retailers            @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchants           merchants?           @relation(fields: [merchantId], references: [id], onDelete: SetNull)
  sources             sources?             @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  source_products     source_products?     @relation(fields: [sourceProductId], references: [id])
  retailer_skus       retailer_skus?       @relation(fields: [retailerSkuId], references: [id], onDelete: SetNull)
  product_reports     product_reports[]

  @@index([inStock])
  @@index([productId])
  @@index([retailerId])
  @@index([sourceProductId])
  @@index([merchantId])
  @@index([sourceId])
  @@index([retailerSkuId])
  // REMOVED: @@index([ingestionRunType]) - unused, no query filtering on this column
  @@index([ingestionRunId])
  @@index([observedAt])
}

// DELETED: pricing_snapshots model (benchmark subsystem removed for v1)

/// ADR-015: Corrections overlay for price history.
/// Corrections are explicit, auditable overlays that modify how facts are interpreted.
/// Facts (prices, pricing_snapshots) are never mutated; corrections change visibility/value at read time.
model price_corrections {
  id String @id @default(cuid())

  /// Scope type determines what entity the correction applies to
  scopeType PriceCorrectionScopeType
  /// ID of the scoped entity (productId, retailerId, merchantId, sourceId, affiliateId, or runId)
  scopeId   String

  /// Time window for the correction (observedAt must be in [startTs, endTs))
  startTs DateTime
  endTs   DateTime

  /// What action to take
  action PriceCorrectionAction

  /// Value for MULTIPLIER action (e.g., 0.9 for 10% discount correction)
  /// Must be NULL for IGNORE action
  value Decimal? @db.Decimal(10, 4)

  /// Human-readable reason for the correction
  reason String

  /// Audit fields for creation
  createdAt DateTime @default(now())
  createdBy String

  /// Soft-revoke fields - corrections are never deleted
  revokedAt    DateTime?
  revokedBy    String?
  revokeReason String?

  @@index([scopeType, scopeId])
  @@index([startTs, endTs])
  @@index([revokedAt])
  @@index([createdAt])
}

/// ADR-015: Derived table for current visible prices.
/// Materialized by CURRENT_PRICE_RECOMPUTE job.
/// Hot paths (Search, Dashboard, Alerts) read from this table instead of evaluating corrections at query time.
/// Contains prices with:
/// - IGNORE corrections excluded
/// - MULTIPLIER corrections applied to visiblePrice
/// - Ignored runs excluded
/// - Retailer visibility applied
/// - Within lookback window
model current_visible_prices {
  id String @id /// Same as prices.id

  // Core linkage
  productId       String?
  retailerId      String
  merchantId      String?
  sourceId        String?
  sourceProductId String?

  // Price data
  price        Decimal @db.Decimal(10, 2) /// Raw price from prices table
  visiblePrice Decimal @db.Decimal(10, 2) /// After MULTIPLIER corrections applied
  currency     String  @default("USD")
  url          String
  inStock      Boolean

  // Timestamps
  observedAt DateTime

  // Shipping
  shippingCost Decimal? @db.Decimal(10, 2)

  // Denormalized retailer info (avoid JOIN in hot paths)
  retailerName String
  retailerTier RetailerTier

  // Provenance
  ingestionRunType IngestionRunType?
  ingestionRunId   String?

  // Recompute tracking
  recomputedAt   DateTime @default(now())
  recomputeJobId String?

  // Indexes for hot-path queries
  @@index([productId])
  @@index([retailerId])
  @@index([sourceProductId])
  @@index([observedAt])
  @@index([inStock])
  @@index([recomputedAt])

  @@map("current_visible_prices")
}

model product_reports {
  id          String           @id @default(cuid())
  productId   String
  userId      String?
  priceId     String?
  issueType   ProductIssueType
  description String
  status      ReportStatus     @default(PENDING)
  reviewedBy  String?
  reviewNotes String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  resolvedAt  DateTime?
  prices      prices?          @relation(fields: [priceId], references: [id])
  products    products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users       users?           @relation(fields: [userId], references: [id])
}

model products {
  id                    String                 @id @default(cuid())
  name                  String
  description           String?
  category              String
  brand                 String?
  imageUrl              String?
  upc                   String?                @unique
  caliber               String?
  grainWeight           Int?
  caseMaterial          String?
  purpose               String?
  roundCount            Int?
  metadata              Json?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  embedding             Unsupported("vector")?
  /// When the embedding was last generated (for staleness tracking)
  lastEmbeddedAt        DateTime?
  barrelLengthReference Decimal?               @db.Decimal(4, 2)
  bulletType            BulletType?
  controlledExpansion   Boolean?
  dataConfidence        Decimal?               @db.Decimal(3, 2)
  dataSource            DataSource?            @default(UNKNOWN)
  factoryNew            Boolean?               @default(true)
  isSubsonic            Boolean?
  lowFlash              Boolean?
  lowRecoil             Boolean?
  matchGrade            Boolean?
  muzzleVelocityFps     Int?
  pressureRating        PressureRating?        @default(STANDARD)
  shortBarrelOptimized  Boolean?
  suppressorSafe        Boolean?

  // ═══════════════════════════════════════════════════════════════════════════
  // Product Resolver fields (Spec v1.2 §0.1)
  // ═══════════════════════════════════════════════════════════════════════════

  /// Immutable canonical key for product identity. Format: "UPC:<upcNorm>" or "FP:<hash>"
  /// Per Spec v1.2: MUST NOT change after creation.
  canonicalKey String? @unique
  /// Normalized UPC (12-digit, no check digit issues). Immutable after creation.
  upcNorm      String? @unique
  /// Normalized brand name for fingerprint matching
  brandNorm    String?
  /// Normalized caliber for fingerprint matching
  caliberNorm  String?
  /// Additive-only product specifications (grain, packCount, etc.)
  specs        Json?

  // ═══════════════════════════════════════════════════════════════════════════
  // Ammo SKU Supersession (per firearm_preferred_ammo_mapping_spec_v3)
  // ═══════════════════════════════════════════════════════════════════════════

  /// Whether this SKU is currently active in the catalog
  isActiveSku     Boolean   @default(true)
  /// Reference to the SKU that supersedes this one (for alias resolution)
  supersededById  String?
  /// When this SKU was superseded
  supersededAt    DateTime?

  // Relations
  /// Self-relation: this product is superseded by another product
  supersededBy    products? @relation("ProductSupersession", fields: [supersededById], references: [id])
  /// Self-relation: products that this product supersedes
  supersedes      products[] @relation("ProductSupersession")
  alerts                   alerts[]
  prices                   prices[]
  product_reports          product_reports[]
  source_products          source_products[]
  watchlist_items          watchlist_items[]
  product_links            product_links[]
  aliasesFrom              product_aliases[]          @relation("AliasFrom")
  aliasesTo                product_aliases[]          @relation("AliasTo")
  product_resolve_requests product_resolve_requests[]
  firearm_ammo_preferences firearm_ammo_preferences[]

  @@index([bulletType])
  @@index([caliber])
  @@index([isSubsonic])
  @@index([pressureRating])
  @@index([purpose])
  @@index([brandNorm, caliberNorm])
}

/// Unified quarantine table for all feed types (retailer and affiliate)
/// Records that fail trust-critical validation are stored here for review
model quarantined_records {
  id               String             @id @default(cuid())
  feedType         QuarantineFeedType @default(RETAILER)
  feedId           String // ID of retailer_feeds or affiliate_feeds (no FK for flexibility)
  runId            String?
  retailerId       String? // For retailer feeds: denormalized retailerId
  sourceId         String? // For affiliate feeds: sourceId for grouping
  productType      String?
  matchKey         String // Identity key for deduplication
  rawData          Json // Original parsed product data
  parsedFields     Json? // Partially normalized fields
  blockingErrors   Json // Array of error codes/messages
  status           QuarantineStatus   @default(QUARANTINED)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  feed_corrections feed_corrections[]

  @@unique([feedId, matchKey])
  @@index([feedType])
  @@index([feedId, status])
  @@index([status])
  @@index([retailerId])
  @@index([sourceId])
}

model retailers {
  id        String       @id @default(cuid())
  name      String
  website   String       @unique
  logoUrl   String?
  tier      RetailerTier @default(STANDARD)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  /// Consumer visibility state per ADR-005.
  /// ELIGIBLE = visible in consumer search, alerts, watchlists
  /// INELIGIBLE = hidden from consumers (policy, data quality, etc.)
  /// SUSPENDED = explicit block, under review
  visibilityStatus    RetailerVisibility @default(ELIGIBLE)
  visibilityReason    String?
  visibilityUpdatedAt DateTime?
  visibilityUpdatedBy String?

  prices             prices[]
  sources            sources[]
  subscriptions      subscriptions[]
  merchant_retailers merchant_retailers[]
  retailer_feeds     retailer_feeds[]
  retailer_skus      retailer_skus[]
  click_events       click_events[]

  @@index([visibilityStatus])
}

model source_product_presence {
  id                String          @id @default(cuid())
  sourceProductId   String          @unique
  lastSeenAt        DateTime
  lastSeenSuccessAt DateTime?
  updatedAt         DateTime        @updatedAt
  source_products   source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  @@index([lastSeenSuccessAt])
}

model source_product_seen {
  id                  String              @id @default(cuid())
  runId               String
  sourceProductId     String
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)
  source_products     source_products     @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)
  // REMOVED: @@index([runId]) - redundant, covered by unique([runId, sourceProductId])

  @@unique([runId, sourceProductId])
}

/// One row per product per source. Contains product attributes.
/// Identifiers now live in source_product_identifiers child table.
/// Identity mapping lives in product_links table (Spec v1.2).
model source_products {
  id       String @id @default(cuid())
  sourceId String

  // Product attributes
  title         String
  url           String
  imageUrl      String?
  brand         String?
  brandNorm     String? // Normalized brand for alias matching and impact estimation
  description   String?
  category      String?
  caliber       String?
  grainWeight   Int?
  roundCount    Int?
  normalizedUrl String?

  // Legacy: Direct product linkage (deprecated, use product_links instead)
  // Kept for backward compatibility during migration
  productId String?

  // Run tracking
  createdByRunId     String?
  lastUpdatedByRunId String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // ═══════════════════════════════════════════════════════════════════════════
  // Product Resolver fields (Spec v1.2 §0.1)
  // ═══════════════════════════════════════════════════════════════════════════

  /// Hash of normalized input fields for reconciliation trigger detection.
  /// Per Spec v1.2 §6: Resolver compares this against prior inputHash.
  normalizedHash String?

  /// Canonical identity key for this source product.
  /// Namespaced string: "upc:12345678901", "sku:ABC123", "urlhash:deadbeef"
  /// Precedence: UPC > SKU > URL hash. Used for idempotency and dedup.
  identityKey String?

  // Relations
  prices                     prices[]
  source_product_presence    source_product_presence?
  source_product_seen        source_product_seen[]
  source_product_identifiers source_product_identifiers[]
  sources                    sources                      @relation(fields: [sourceId], references: [id])
  products                   products?                    @relation(fields: [productId], references: [id])
  product_links              product_links?
  product_resolve_requests   product_resolve_requests[]
  click_events               click_events[]

  @@index([productId])
  @@index([sourceId])
  @@index([normalizedHash])
  @@index([identityKey]) // For dedupe and idempotency lookups
  @@index([brandNorm, createdAt]) // For brand alias impact estimation
}

/// All identifiers observed for a source product.
/// Supports multiple identifier types per product (SKU, UPC, network IDs, etc.)
/// One identifier is marked canonical for upsert/dedupe purposes.
model source_product_identifiers {
  id              String         @id @default(cuid())
  sourceProductId String
  idType          IdentifierType
  idValue         String
  /// Namespace for scoping: network name (IMPACT, AVANTLINK), retailer ID, etc.
  /// Required for NETWORK_ITEM_ID, MERCHANT_SKU. Empty string for universal codes (UPC, EAN).
  namespace       String         @default("")
  /// Exactly one identifier per source_product should be canonical (used for upsert matching)
  isCanonical     Boolean        @default(false)
  /// Normalized value for consistent matching (trimmed, uppercased where appropriate)
  normalizedValue String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  source_products source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  // Unique: same identifier can't appear twice for same product
  @@unique([sourceProductId, idType, idValue, namespace], name: "source_product_identifiers_unique")
  // Fast lookup by identifier (for find-by-any-identifier upsert)
  @@index([idType, idValue, namespace], name: "source_product_identifiers_lookup")
  // Find canonical identifier for a product
  @@index([sourceProductId, isCanonical], name: "source_product_identifiers_canonical")
}

// ═══════════════════════════════════════════════════════════════════════════════
// Product Resolver Tables (Spec v1.2)
// ═══════════════════════════════════════════════════════════════════════════════

/// Product Resolver control plane. Stores all identity decisions.
/// This is the source of truth for source_product → product linkage.
/// Per Spec v1.2 §0.0: All product grouping MUST join through this table.
model product_links {
  id              String  @id @default(cuid())
  sourceProductId String  @unique
  productId       String?

  /// How the link was established
  matchType       ProductLinkMatchType
  /// Current resolution status
  status          ProductLinkStatus
  /// Why resolution resulted in UNMATCHED or ERROR (null for MATCHED/CREATED)
  reasonCode      ProductLinkReasonCode?
  /// Match confidence score (0.0-1.0), deterministic
  confidence      Decimal                @db.Decimal(5, 4)
  /// Resolver version that made this decision
  resolverVersion String

  /// Full audit trail: inputNormalized, inputHash, dictionaryVersion,
  /// trustConfigVersion, rulesFired, candidates, previousDecision (if relink)
  evidence Json

  /// When resolver logic last ran (not just row update)
  resolvedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  source_products source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)
  products        products?       @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([productId])
  // REMOVED: @@index([status]) - redundant, covered by @@index([status, matchType])
  @@index([matchType])
  @@index([status, matchType]) // For filtered queries by resolution state
  @@index([resolverVersion])
  @@index([resolvedAt])
}

/// Brand alias mapping for resolver normalization.
/// Per brand-aliases-v1 spec: Admin-managed, auditable mapping from brand aliases
/// to canonical brand names to improve resolver match rates.
model brand_aliases {
  id                   String               @id @default(uuid())
  /// Human-readable canonical brand name
  canonicalName        String
  /// Normalized canonical name (for matching)
  canonicalNorm        String
  /// Normalization rules version used to compute norms
  normalizationVersion Int                  @default(1)
  /// Alias string as entered by admin
  aliasName            String
  /// Normalized alias string (for matching)
  aliasNorm            String               @unique
  /// Status: DRAFT (not applied), ACTIVE (applied in resolver), DISABLED (soft-deleted)
  status               BrandAliasStatus     @default(DRAFT)
  /// Source type: where did this alias come from
  sourceType           BrandAliasSourceType
  /// Reference to source (feed name, partner id, or manual note)
  sourceRef            String?
  /// Example product IDs or rows that motivated this alias
  evidence             Json?
  /// Admin notes for provenance
  notes                String?
  /// Timestamps
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  /// Admin user who created this alias
  createdBy            String
  /// Admin user who last updated this alias
  updatedBy            String
  /// Soft-delete fields
  disabledAt           DateTime?
  disabledBy           String?
  /// Reason for disabling (required when status -> DISABLED)
  /// Prefix with "REJECTED:" to block re-activation
  disableReason        String?

  /// Daily application tracking
  applications brand_alias_applications_daily[]

  @@index([canonicalNorm])
  @@index([status])
  @@index([createdAt])
}

/// Daily application counts for brand aliases.
/// Per brand-aliases-v1 spec: Track impact for investigations and review.
model brand_alias_applications_daily {
  aliasId   String
  date      DateTime @db.Date
  count     Int      @default(0)
  updatedAt DateTime @updatedAt

  brand_aliases brand_aliases @relation(fields: [aliasId], references: [id], onDelete: Cascade)

  @@id([aliasId, date])
  @@index([date])
  @@index([aliasId])
}

/// Alias mapping for canonical product merges.
/// Allows product consolidation without rewriting history.
/// Per Spec v1.2 §0.1: Resolver MUST resolve through aliases before persisting links.
model product_aliases {
  id            String   @id @default(cuid())
  /// Product being aliased (merged away)
  fromProductId String   @unique
  /// Target product (winner of merge)
  toProductId   String
  /// Why the merge happened
  reason        String
  createdAt     DateTime @default(now())
  createdBy     String?

  // Relations - both point to products table
  // Note: fromProduct is the "loser" that should not be used directly
  fromProduct products @relation("AliasFrom", fields: [fromProductId], references: [id], onDelete: Restrict)
  toProduct   products @relation("AliasTo", fields: [toProductId], references: [id], onDelete: Restrict)

  @@index([toProductId])
}

/// Tracks product resolution requests for intent, dedup, and retries.
/// Separate from product_links (which tracks outcomes).
/// Per Spec: idempotencyKey = sourceId + ":" + identityKey
model product_resolve_requests {
  id String @id @default(cuid())

  /// sourceId + ":" + identityKey (e.g., "src123:upc:012345678901")
  idempotencyKey  String @unique
  sourceProductId String
  sourceId        String

  /// Current status of this request
  status ProductResolveRequestStatus @default(PENDING)

  /// Number of processing attempts
  attempts      Int       @default(0)
  /// Last attempt timestamp
  lastAttemptAt DateTime?
  /// Error message if FAILED
  errorMessage  String?

  /// Resulting productId if created/matched (denormalized for quick lookup)
  resultProductId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  source_products source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)
  sources         sources         @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  products        products?       @relation(fields: [resultProductId], references: [id], onDelete: SetNull)

  @@index([sourceProductId])
  @@index([sourceId])
  // REMOVED: @@index([status]) - redundant, covered by @@index([status, updatedAt])
  @@index([createdAt])
  @@index([status, updatedAt]) // For worker polling queries
}

/// Per-source trust configuration for identifier eligibility.
/// Per Spec v1.2 §0.1: Resolver uses this to determine if UPC is trusted.
model source_trust_config {
  id         String   @id @default(cuid())
  sourceId   String   @unique
  /// Whether UPC codes from this source are trusted for canonical matching
  upcTrusted Boolean  @default(false)
  /// Config version, incremented on every change, recorded in link evidence
  version    Int      @default(1)
  updatedAt  DateTime @updatedAt
  updatedBy  String?

  sources sources @relation(fields: [sourceId], references: [id], onDelete: Cascade)
}

model sources {
  id                        String                     @id @default(cuid())
  name                      String
  url                       String
  type                      SourceType                 @default(HTML)
  enabled                   Boolean                    @default(true)
  interval                  Int                        @default(3600)
  lastRunAt                 DateTime?
  paginationConfig          Json?
  affiliateNetwork          AffiliateNetwork?
  feedHash                  String?
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  retailerId                String
  affiliateAccountId        String?
  affiliateAccountName      String?
  affiliateAdvertiserId     String?
  affiliateCampaignId       String?
  affiliateProgramId        String?
  affiliateTrackingTemplate String?
  isDisplayPrimary          Boolean                    @default(false)
  sourceKind                SourceKind                 @default(DIRECT)
  affiliate_feeds           affiliate_feeds[]
  executions                executions[]
  source_products           source_products[]
  prices                    prices[]
  retailers                 retailers                  @relation(fields: [retailerId], references: [id])
  source_trust_config       source_trust_config?
  product_resolve_requests  product_resolve_requests[]
  click_events              click_events[]

  @@index([retailerId], map: "sources_retailer_id_idx")
}

model subscriptions {
  id         String             @id @default(cuid())
  userId     String?
  retailerId String?
  type       SubscriptionType
  status     SubscriptionStatus @default(ACTIVE)
  startDate  DateTime           @default(now())
  endDate    DateTime?
  amount     Decimal            @db.Decimal(10, 2)
  currency   String             @default("USD")
  stripeId   String?            @unique
  retailers  retailers?         @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  users      users?             @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model system_settings {
  key         String   @id @default(cuid())
  value       Json
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
}

model users {
  id                    String                  @id @default(cuid())
  email                 String                  @unique
  name                  String?
  image                 String?
  password              String?
  emailVerified         DateTime?
  tier                  UserTier                @default(FREE)
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  deletionRequestedAt   DateTime?
  deletionScheduledFor  DateTime?
  status                UserStatus              @default(ACTIVE)
  Account               Account[]
  Session               Session[]
  alerts                alerts[]
  data_subscriptions    data_subscriptions[]
  product_reports       product_reports[]
  subscriptions         subscriptions[]
  user_guns                user_guns[]
  watchlist_collections    watchlist_collections[]
  watchlist_items          watchlist_items[]
  firearm_ammo_preferences firearm_ammo_preferences[]
}

/// Gun Locker - stores guns a user owns for deal personalization
model user_guns {
  id        String   @id @default(cuid())
  userId    String
  caliber   String   // Canonical caliber value from CaliberEnum
  nickname  String?
  imageUrl  String?  @db.Text // base64 data URL (Postgres-first), R2 URL later
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ammo preferences for this firearm
  firearm_ammo_preferences firearm_ammo_preferences[]

  @@index([userId])
}

/// Firearm → Preferred Ammo Mapping (per firearm_preferred_ammo_mapping_spec_v3)
/// User-declared ammo usage context for a firearm. Not a recommendation system.
/// Supports recall and re-purchase workflows, not discovery or advice.
model firearm_ammo_preferences {
  id         String                       @id @default(cuid())
  userId     String
  firearmId  String
  ammoSkuId  String                        // References products.id (ammo SKU)
  useCase    AmmoUseCase
  createdAt  DateTime                      @default(now())
  updatedAt  DateTime                      @updatedAt
  deletedAt  DateTime?
  deleteReason AmmoPreferenceDeleteReason?

  // Relations
  // Per spec: Soft-delete semantics for all deletions
  // userId NO ACTION: App handles via cascadeUserDeletion() for audit trail
  // firearmId NO ACTION: App handles via cascadeFirearmDeletion() for audit trail
  // ammoSkuId NO ACTION: Products should never be hard-deleted per spec
  // Future GDPR purge: soft-delete with reasons first, then hard-delete user
  users      users      @relation(fields: [userId], references: [id], onDelete: NoAction)
  user_guns  user_guns  @relation(fields: [firearmId], references: [id], onDelete: NoAction)
  products   products   @relation(fields: [ammoSkuId], references: [id], onDelete: NoAction)

  // Partial unique: only one active mapping per user+firearm+sku+useCase
  // Per spec: UNIQUE (user_id, firearm_id, ammo_sku_id, use_case) WHERE deleted_at IS NULL
  // Prisma doesn't support partial indexes, so this is managed via raw SQL migration.
  // See migration: 20260125_firearm_ammo_preferences

  // Recommended indexes per spec
  @@index([userId, firearmId, deletedAt])
  @@index([userId, ammoSkuId, deletedAt])
  @@index([userId, useCase, deletedAt])
}

model watchlist_collections {
  id              String            @id @default(cuid())
  userId          String
  name            String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  users           users             @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items[]

  @@index([userId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// ADR-011A: Intent-Ready Saved Items (WatchlistItem Resolver Seam)
/// Supports SKU intent (v1) with schema-level preparation for future SEARCH intent.
/// See context/decisions/ADR-017-Intent-Ready-Saved-Items.md for full specification.
model watchlist_items {
  id           String   @id @default(cuid())
  userId       String
  productId    String? /// Nullable for future SEARCH intent; v1 enforces non-null for SKU
  collectionId String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  /// ADR-011A: Intent-ready fields
  intentType    String    @default("SKU") @map("intent_type")
  querySnapshot Json?     @map("query_snapshot") /// For future SEARCH intent
  deletedAt     DateTime? @map("deleted_at") /// Soft delete timestamp

  /// Notification preferences (per ADR-011)
  notificationsEnabled    Boolean   @default(true)
  priceDropEnabled        Boolean   @default(true)
  backInStockEnabled      Boolean   @default(true)
  minDropPercent          Int       @default(5)
  minDropAmount           Decimal   @default(5.0) @db.Decimal(10, 2)
  stockAlertCooldownHours Int       @default(24)
  lastStockNotifiedAt     DateTime?
  lastPriceNotifiedAt     DateTime?

  /// Two-phase notification claim fields (prevents duplicate sends under concurrency)
  /// Claim is stale after 5 minutes (allows retry if worker crashes)
  priceNotificationClaimedAt DateTime? @map("price_notification_claimed_at")
  priceNotificationClaimKey  String?   @map("price_notification_claim_key")
  stockNotificationClaimedAt DateTime? @map("stock_notification_claimed_at")
  stockNotificationClaimKey  String?   @map("stock_notification_claim_key")

  /// Relations
  alerts                alerts[]
  watchlist_collections watchlist_collections? @relation(fields: [collectionId], references: [id])
  products              products?              @relation(fields: [productId], references: [id], onDelete: Cascade)
  users                 users                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Note: Uniqueness for active SKU items enforced by PARTIAL unique index in migration:
  // CREATE UNIQUE INDEX watchlist_items_sku_active_uniq ON watchlist_items (user_id, product_id)
  //   WHERE intent_type = 'SKU' AND deleted_at IS NULL AND product_id IS NOT NULL;
  // Prisma doesn't support partial indexes in schema, so this is managed via raw SQL migration.
  // See ADR-011A Section 19.1
  @@index([collectionId])
  @@index([productId])
  @@index([userId])
  @@index([deletedAt], map: "watchlist_items_deleted_at_idx")
  @@index([intentType], map: "watchlist_items_intent_type_idx")
}

// DELETED: AdType enum (unused after advertisements model removed)

enum AffiliateFeedRunStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

enum AffiliateFeedRunTrigger {
  SCHEDULED
  MANUAL
  MANUAL_PENDING
  ADMIN_TEST
  RETRY
}

enum AffiliateFeedStatus {
  DRAFT
  ENABLED
  PAUSED
  DISABLED
}

enum AffiliateNetwork {
  IMPACT
  AVANTLINK
  SHAREASALE
  CJ
  RAKUTEN
}

enum BrandAliasSourceType {
  RETAILER_FEED
  AFFILIATE_FEED
  MANUAL
}

enum BrandAliasStatus {
  DRAFT
  ACTIVE
  DISABLED
}

enum AlertRuleType {
  PRICE_DROP
  BACK_IN_STOCK
}

enum AlertType {
  PRICE_DROP
  BACK_IN_STOCK
  NEW_PRODUCT
}

// DELETED: BenchmarkConfidence enum (benchmark subsystem removed for v1)
// DELETED: BenchmarkSource enum (benchmark subsystem removed for v1)

enum BulletType {
  JHP
  HP
  BJHP
  XTP
  HST
  GDHP
  VMAX
  FMJ
  TMJ
  CMJ
  MC
  BALL
  SP
  JSP
  PSP
  RN
  FPRN
  FRANGIBLE
  AP
  TRACER
  BLANK
  WADCUTTER
  SWC
  LSWC
  BUCKSHOT
  BIRDSHOT
  SLUG
  OTHER
}

enum DaaSPlan {
  BASIC
  PROFESSIONAL
  ENTERPRISE
}

enum DataSource {
  MANUFACTURER
  RETAILER_FEED
  PARSED
  MANUAL
  AI_INFERRED
  UNKNOWN
}

enum MerchantContactRole {
  PRIMARY
  BILLING
  TECHNICAL
  MARKETING
  OTHER
}

enum MerchantPaymentMethod {
  STRIPE
  PURCHASE_ORDER
}

enum MerchantStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum MerchantSubscriptionStatus {
  ACTIVE
  EXPIRED
  SUSPENDED
  CANCELLED
}

enum MerchantTier {
  FOUNDING
  BASIC
  PRO
  ENTERPRISE
}

enum MerchantUserRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

/// Status of a merchant-retailer relationship
enum MerchantRetailerStatus {
  /// Active relationship, merchant can manage retailer
  ACTIVE
  /// Relationship pending approval
  PENDING
  /// Relationship suspended
  SUSPENDED
  /// Relationship terminated
  INACTIVE
}

/// Listing status for consumer visibility (paid entitlement).
/// Per Merchant-and-Retailer-Reference: Merchant pays to list each retailer.
enum MerchantRetailerListingStatus {
  /// Retailer is listed and visible to consumers (if also ELIGIBLE)
  LISTED
  /// Retailer is unlisted, hidden from consumers
  UNLISTED
}

/// Role for a merchant user on a specific retailer
enum MerchantRetailerRole {
  /// Full access to retailer management
  ADMIN
  /// Can edit feeds and data
  EDITOR
  /// Read-only access
  VIEWER
}

/// ADR-015: Type of ingestion run for price provenance tracking
enum IngestionRunType {
  /// Scraped from retailer website via executions
  SCRAPE
  /// From affiliate feed via affiliate_feed_runs
  AFFILIATE_FEED
  /// From merchant portal feed via retailer_feed_runs (legacy: dealer_feed_runs)
  RETAILER_FEED
  /// Manual entry or import
  MANUAL
}

/// ADR-015: Scope types for price corrections
/// Precedence: PRODUCT > RETAILER > MERCHANT > SOURCE > AFFILIATE > FEED_RUN
enum PriceCorrectionScopeType {
  /// Correction applies to a specific product
  PRODUCT
  /// Correction applies to all prices from a retailer
  RETAILER
  /// Correction applies to all prices from a merchant
  MERCHANT
  /// Correction applies to all prices from a source
  SOURCE
  /// Correction applies to all prices from an affiliate
  AFFILIATE
  /// Correction applies to all prices from a specific feed run
  FEED_RUN
}

/// ADR-015: Actions for price corrections
enum PriceCorrectionAction {
  /// Exclude matching prices from all user-visible queries
  IGNORE
  /// Apply a multiplier to matching prices (visible_price = raw_price * value)
  MULTIPLIER
}

enum ExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum FeedAccessType {
  URL
  AUTH_URL
  FTP
  SFTP
  UPLOAD
}

enum FeedCompression {
  NONE
  GZIP
}

enum FeedFormat {
  CSV
}

/// Feed variant for supporting multiple feeds per source
/// Used with affiliate_feeds to distinguish full vs delta, regional splits, etc.
enum FeedVariant {
  FULL // Complete catalog refresh
  DELTA // Incremental updates only
  REGIONAL_US // US-specific catalog
  REGIONAL_CA // Canada-specific catalog
  REGIONAL_EU // EU-specific catalog
  CATEGORY_AMMO // Ammo-only feed
  CATEGORY_ACCESSORIES // Accessories-only feed
}

enum FeedFormatType {
  GENERIC
  AMMOSEEK_V1
  GUNENGINE_V2
  IMPACT
}

enum FeedRunStatus {
  RUNNING
  SUCCESS
  WARNING
  FAILURE
  PENDING
  SKIPPED
}

enum FeedStatus {
  PENDING
  HEALTHY
  WARNING
  FAILED
}

enum FeedTransport {
  FTP
  SFTP
}

// DELETED: InsightConfidence enum (benchmark subsystem removed for v1)
// DELETED: InsightType enum (benchmark subsystem removed for v1)

enum LogLevel {
  INFO
  WARN
  ERROR
}

// DELETED: MappingConfidence enum (benchmark subsystem removed for v1)

enum PressureRating {
  STANDARD
  PLUS_P
  PLUS_P_PLUS
  NATO
  UNKNOWN
}

enum PriceType {
  REGULAR
  SALE
  CLEARANCE
}

enum ProductIssueType {
  INCORRECT_PRICE
  OUT_OF_STOCK
  INCORRECT_INFO
  BROKEN_LINK
  WRONG_PRODUCT
  SPAM
  OTHER
}

enum QuarantineStatus {
  QUARANTINED
  RESOLVED
  DISMISSED
}

enum QuarantineFeedType {
  RETAILER
  AFFILIATE
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum RetailerTier {
  STANDARD
  PREMIUM
}

/// Retailer visibility state for consumer-facing queries.
/// Per ADR-005: Eligibility applies to Retailer visibility only.
/// This is the authoritative source for consumer visibility filtering.
enum RetailerVisibility {
  /// Retailer is visible in consumer search, alerts, watchlists
  ELIGIBLE
  /// Retailer is hidden from consumers (policy, data quality, etc.)
  INELIGIBLE
  /// Retailer is suspended (explicit block, under review)
  SUSPENDED
}

enum ShippingType {
  FLAT
  PER_UNIT
  CALCULATED
  FREE
  UNKNOWN
}

enum SourceKind {
  DIRECT
  AFFILIATE_FEED
  OTHER
}

/// Comprehensive identifier types for source_product_identifiers
/// Supports all affiliate networks, retailer feeds, and standard product codes
enum IdentifierType {
  // Standard product codes
  SKU // Retailer-specific stock keeping unit
  UPC // Universal Product Code (12-digit)
  EAN // European Article Number (13-digit)
  GTIN // Global Trade Item Number (8, 12, 13, or 14 digit)
  MPN // Manufacturer Part Number
  ASIN // Amazon Standard Identification Number

  // URL-based identifiers
  URL // Canonical product URL
  URL_HASH // Hash of normalized URL (fallback identity)

  // Network-specific identifiers (use with namespace)
  NETWORK_ITEM_ID // Affiliate network's item ID (namespace: IMPACT, AVANTLINK, etc.)
  MERCHANT_SKU // Merchant-provided SKU (namespace: retailer ID)

  // Internal identifiers
  INTERNAL_ID // IronScout-generated identifier
}

enum SourceType {
  HTML
  JS_RENDERED
  RSS
  JSON
  FEED_CSV
  FEED_XML
  FEED_JSON
}

enum StoreType {
  ONLINE_ONLY
  RETAIL_AND_ONLINE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum SubscriptionType {
  USER_PREMIUM
  RETAILER_PREMIUM
}

enum TestRunStatus {
  PASS
  WARN
  FAIL
}

enum UserStatus {
  ACTIVE
  PENDING_DELETION
  DELETED
}

enum UserTier {
  FREE
  PREMIUM
}

// ═══════════════════════════════════════════════════════════════════════════════
// Firearm Ammo Preference Enums (per firearm_preferred_ammo_mapping_spec_v3)
// ═══════════════════════════════════════════════════════════════════════════════

/// Use case for firearm ammo preference. Descriptive only, no hierarchy.
/// Per spec: "Use cases are descriptive only and imply no hierarchy."
enum AmmoUseCase {
  TRAINING
  CARRY
  COMPETITION
  GENERAL
}

/// Reason for soft-deleting a firearm ammo preference.
/// Per spec lifecycle semantics.
enum AmmoPreferenceDeleteReason {
  /// User explicitly removed the mapping
  USER_REMOVED
  /// Parent firearm was deleted (cascade)
  FIREARM_DELETED
  /// Ammo SKU was superseded by another SKU
  SKU_SUPERSEDED
  /// Administrative cleanup
  ADMIN_CLEANUP
}

// ═══════════════════════════════════════════════════════════════════════════════
// Product Resolver Enums (Spec v1.2)
// ═══════════════════════════════════════════════════════════════════════════════

/// Match type for product_links. Determines how a source_product was linked to a canonical product.
enum ProductLinkMatchType {
  /// Matched via trusted UPC code
  UPC
  /// Matched via fingerprint scoring (brand, caliber, pack, grain, title)
  FINGERPRINT
  /// Manually linked by admin/operator
  MANUAL
  /// No match found (data insufficient or ambiguous)
  NONE
  /// Resolution failed with system error
  ERROR
}

/// Status of a product_links resolution.
enum ProductLinkStatus {
  /// Linked to existing canonical product
  MATCHED
  /// Created new canonical product and linked
  CREATED
  /// @deprecated Use NEEDS_REVIEW instead. Kept for backward compatibility with existing data.
  /// Will be migrated to NEEDS_REVIEW in future cleanup.
  UNMATCHED
  /// Awaiting human review (insufficient data, ambiguous match, or flagged)
  /// This is the correct terminal state for "could not decide" cases.
  NEEDS_REVIEW
  /// Manually skipped by admin during review (deferred, not actionable, etc.)
  /// Terminal state - removed from active review queue.
  SKIPPED
  /// Resolution failed with system error
  ERROR
}

/// Reason codes for UNMATCHED or ERROR status in product_links.
enum ProductLinkReasonCode {
  /// Missing required fields for any match strategy
  INSUFFICIENT_DATA
  /// UPC present but invalid format
  INVALID_UPC
  /// UPC present but source is not trusted for UPC
  UPC_NOT_TRUSTED
  /// Fingerprint score in ambiguous range or too close to second-best
  AMBIGUOUS_FINGERPRINT
  /// Match candidate has conflicting immutable identifiers
  CONFLICTING_IDENTIFIERS
  /// Existing link is MANUAL and cannot be overridden
  MANUAL_LOCKED
  /// Relink blocked by hysteresis (confidence delta too small)
  RELINK_BLOCKED_HYSTERESIS
  /// System error during resolution (DB, timeout, etc.)
  SYSTEM_ERROR
  /// All normalization attempts failed
  NORMALIZATION_FAILED
}

/// Status of a product resolve request.
enum ProductResolveRequestStatus {
  /// Queued, waiting to be processed
  PENDING
  /// Currently being processed
  PROCESSING
  /// Successfully resolved (see product_links for outcome)
  COMPLETED
  /// Failed to process (see errorMessage)
  FAILED
}
