generator client {
  provider        = "prisma-client-js"
  output          = "./generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  users             users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  users        users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model admin_audit_logs {
  id          String   @id @default(cuid())
  adminUserId String
  merchantId  String?
  action      String
  resource    String?
  resourceId  String?
  oldValue    Json?
  newValue    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([action])
  @@index([adminUserId])
  @@index([createdAt])
  @@index([merchantId])
}

model advertisements {
  id          String   @id @default(cuid())
  title       String
  description String
  imageUrl    String?
  targetUrl   String
  adType      AdType   @default(DISPLAY)
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model affiliate_feed_run_errors {
  id                  String              @id @default(cuid())
  runId               String
  code                String
  message             String
  rowNumber           Int?
  sample              Json?
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model affiliate_feed_runs {
  id                   String                  @id @default(cuid())
  feedId               String
  sourceId             String
  trigger              AffiliateFeedRunTrigger @default(SCHEDULED)
  status               AffiliateFeedRunStatus  @default(RUNNING)
  startedAt            DateTime                @default(now())
  finishedAt           DateTime?
  durationMs           Int?
  downloadBytes        BigInt?
  rowsRead             Int?
  rowsParsed           Int?
  productsUpserted     Int?
  pricesWritten        Int?
  productsPromoted     Int?
  errorCount           Int?
  productsExpired      Int?
  productsRejected     Int?
  duplicateKeyCount    Int?
  urlHashFallbackCount Int?
  activeCountBefore    Int?
  seenSuccessCount     Int?
  wouldExpireCount     Int?
  skippedReason        String?
  failureKind          String?
  failureCode          String?
  failureMessage       String?
  isPartial            Boolean                 @default(false)
  expiryStepFailed     Boolean                 @default(false)
  expiryBlocked        Boolean                 @default(false)
  expiryBlockedReason  String?
  expiryApprovedAt     DateTime?
  expiryApprovedBy     String?
  artifactUrl          String?
  correlationId        String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  affiliate_feed_run_errors affiliate_feed_run_errors[]
  affiliate_feeds           affiliate_feeds             @relation(fields: [feedId], references: [id], onDelete: Cascade)
  prices                    prices[]
  source_product_seen       source_product_seen[]

  @@index([feedId, startedAt])
  @@index([feedId, status, startedAt])
  @@index([feedId, trigger, startedAt])
  @@index([ignoredAt])
}

model affiliate_feeds {
  id                     String                @id @default(cuid())
  sourceId               String
  variant                FeedVariant           @default(FULL)
  network                AffiliateNetwork
  status                 AffiliateFeedStatus   @default(DRAFT)
  scheduleFrequencyHours Int?
  nextRunAt              DateTime?
  expiryHours            Int                   @default(48)
  consecutiveFailures    Int                   @default(0)
  lastRunAt              DateTime?
  manualRunPending       Boolean               @default(false)
  transport              FeedTransport         @default(SFTP)
  host                   String?
  port                   Int?
  path                   String?
  username               String?
  secretCiphertext       Bytes?
  secretKeyId            String?
  secretVersion          Int                   @default(1)
  format                 FeedFormat            @default(CSV)
  compression            FeedCompression       @default(NONE)
  lastRemoteMtime        DateTime?
  lastRemoteSize         BigInt?
  lastContentHash        String?
  maxFileSizeBytes       BigInt?
  maxRowCount            Int?
  feedLockId             BigInt                @unique @default(autoincrement())
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  createdBy              String?
  affiliate_feed_runs    affiliate_feed_runs[]
  sources                sources               @relation(fields: [sourceId], references: [id])

  @@unique([sourceId, variant])
  @@index([nextRunAt])
  @@index([status])
  @@index([sourceId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model alerts {
  id              String         @id @default(cuid())
  userId          String
  productId       String
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  watchlistItemId String?
  ruleType        AlertRuleType?
  isEnabled       Boolean        @default(true)

  /// ADR-015: Alert suppression for retroactive correction handling
  /// When set, alert is hidden in UI and never re-fired
  suppressedAt     DateTime?
  /// Who suppressed the alert (admin user ID or 'system')
  suppressedBy     String?
  /// Reason for suppression (e.g., 'run_ignored', 'correction_applied')
  suppressedReason String?

  products        products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users           users            @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items? @relation(fields: [watchlistItemId], references: [id], onDelete: Cascade)

  @@unique([userId, productId, ruleType], map: "alerts_userid_productid_ruletype_key")
  @@index([productId])
  @@index([userId])
  @@index([suppressedAt])
  @@index([watchlistItemId])
}

// DELETED: benchmarks model (benchmark subsystem removed for v1)
// DELETED: canonical_skus model (benchmark subsystem removed for v1)

model click_events {
  id         String    @id @default(cuid())
  merchantId String
  sessionId  String?
  userAgent  String?
  ipHash     String?
  referrer   String?
  createdAt  DateTime  @default(now())
  merchants  merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([merchantId])
  @@index([sessionId])
}

model data_subscriptions {
  id        String             @id @default(cuid())
  userId    String
  plan      DaaSPlan           @default(BASIC)
  status    SubscriptionStatus @default(ACTIVE)
  apiKey    String             @unique
  rateLimit Int                @default(1000)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  users     users              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model merchant_contacts {
  id                 String                @id @default(cuid())
  merchantId         String
  firstName          String
  lastName           String
  email              String
  phone              String?
  marketingOptIn     Boolean               @default(false)
  communicationOptIn Boolean               @default(true)
  isAccountOwner     Boolean               @default(false)
  isActive           Boolean               @default(true)
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  roles              MerchantContactRole[] @default([])
  merchants          merchants             @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([email])
}

model retailer_feed_runs {
  id               String        @id @default(cuid())
  retailerId       String
  feedId           String
  status           FeedRunStatus
  errors           Json?
  rowCount         Int           @default(0)
  duration         Int?
  startedAt        DateTime      @default(now())
  completedAt      DateTime?
  primaryErrorCode String?
  quarantinedCount Int           @default(0)
  coercionCount    Int           @default(0)
  errorCodes       Json?
  indexedCount     Int           @default(0)
  rejectedCount    Int           @default(0)
  matchedCount     Int           @default(0)

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  retailer_feeds retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
  @@index([ignoredAt])
}

model retailer_feed_test_runs {
  id               String         @id @default(cuid())
  retailerId       String
  feedId           String
  sampleSize       Int            @default(50)
  status           TestRunStatus
  recordsParsed    Int            @default(0)
  wouldIndex       Int            @default(0)
  wouldQuarantine  Int            @default(0)
  wouldReject      Int            @default(0)
  warningCount     Int            @default(0)
  errorCount       Int            @default(0)
  primaryErrorCode String?
  errorSamples     Json?
  coercionSummary  Json?
  duration         Int?
  startedAt        DateTime       @default(now())
  completedAt      DateTime?
  retailer_feeds   retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
}

model retailer_feeds {
  id                      String                    @id @default(cuid())
  retailerId              String
  name                    String?
  url                     String?
  username                String?
  password                String?
  scheduleMinutes         Int                       @default(60)
  status                  FeedStatus                @default(PENDING)
  feedHash                String?
  lastSuccessAt           DateTime?
  lastFailureAt           DateTime?
  lastError               String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  accessType              FeedAccessType            @default(URL)
  enabled                 Boolean                   @default(true)
  formatType              FeedFormatType            @default(GENERIC)
  lastRunAt               DateTime?
  primaryErrorCode        String?
  retailer_feed_runs      retailer_feed_runs[]
  retailer_feed_test_runs retailer_feed_test_runs[]
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_skus           retailer_skus[]
  feed_corrections        feed_corrections[]
  quarantined_records     quarantined_records[]

  @@index([retailerId])
  @@index([enabled])
}

// DELETED: merchant_insights model (benchmark subsystem removed for v1)

model merchant_invites {
  id             String           @id @default(cuid())
  merchantId     String
  email          String
  role           MerchantUserRole @default(MEMBER)
  inviteToken    String           @unique
  invitedById    String
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime         @default(now())
  merchants      merchants        @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_users merchant_users   @relation(fields: [invitedById], references: [id])

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([inviteToken])
}

model merchant_notification_prefs {
  id                 String    @id @default(cuid())
  merchantId         String    @unique
  fatalFeedErrors    Boolean   @default(true)
  nonFatalFeedIssues Boolean   @default(false)
  successfulUpdates  Boolean   @default(false)
  weeklyPulse        Boolean   @default(true)
  insightAlerts      Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  merchants          merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}

model retailer_skus {
  id                  String                @id @default(cuid())
  retailerId          String
  feedId              String?
  feedRunId           String?
  rawTitle            String
  rawDescription      String?
  rawPrice            Decimal               @db.Decimal(10, 2)
  rawUpc              String?
  rawSku              String?
  rawCaliber          String?
  rawGrain            String?
  rawCase             String?
  rawBulletType       String?
  rawBrand            String?
  rawPackSize         Int?
  rawInStock          Boolean               @default(true)
  rawUrl              String?
  rawImageUrl         String?
  parsedCaliber       String?
  parsedGrain         Int?
  parsedPackSize      Int?
  parsedBulletType    String?
  parsedBrand         String?
  parseConfidence     Decimal?              @db.Decimal(3, 2)
  retailerSkuHash     String?
  isActive            Boolean               @default(true)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  lastSeenAt          DateTime?
  missingCount        Int                   @default(0)
  productType         String?
  coercionsApplied    Json?
  retailers           retailers             @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_feeds      retailer_feeds?       @relation(fields: [feedId], references: [id])

  @@unique([retailerId, retailerSkuHash])
  @@index([retailerId])
  @@index([feedId])
  @@index([isActive])
}

model merchant_users {
  id                      String                    @id @default(cuid())
  merchantId              String
  email                   String
  passwordHash            String
  name                    String
  role                    MerchantUserRole          @default(MEMBER)
  emailVerified           Boolean                   @default(false)
  verifyToken             String?
  resetToken              String?
  resetTokenExp           DateTime?
  lastLoginAt             DateTime?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  merchant_invites        merchant_invites[]
  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([email])
}

model merchants {
  id                          String                       @id @default(cuid())
  businessName                String
  websiteUrl                  String
  phone                       String?
  storeType                   StoreType                    @default(ONLINE_ONLY)
  status                      MerchantStatus               @default(PENDING)
  tier                        MerchantTier                 @default(FOUNDING)
  pixelApiKey                 String?                      @unique
  pixelEnabled                Boolean                      @default(false)
  shippingType                ShippingType                 @default(UNKNOWN)
  shippingFlat                Decimal?                     @db.Decimal(10, 2)
  shippingPerUnit             Decimal?                     @db.Decimal(10, 2)
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  contactFirstName            String
  contactLastName             String
  lastSubscriptionNotifyAt    DateTime?
  subscriptionExpiresAt       DateTime?
  subscriptionGraceDays       Int                          @default(7)
  subscriptionStatus          MerchantSubscriptionStatus   @default(ACTIVE)
  autoRenew                   Boolean                      @default(true)
  paymentMethod               MerchantPaymentMethod?
  stripeCustomerId            String?                      @unique
  stripeSubscriptionId        String?                      @unique
  click_events                click_events[]
  merchant_contacts           merchant_contacts[]
  merchant_invites            merchant_invites[]
  merchant_notification_prefs merchant_notification_prefs?
  merchant_users              merchant_users[]
  pixel_events                pixel_events[]
  merchant_retailers          merchant_retailers[]
  prices                      prices[]
}

/// Explicit Merchant↔Retailer relationship.
/// Per Merchant-and-Retailer-Reference: One Merchant can administer many Retailers.
/// This replaces the deprecated retailers.merchantId optional field.
/// Merchant-Retailer relationship. One Merchant can have many Retailers, one Retailer can have many Merchants.
/// The @@unique([merchantId, retailerId]) constraint prevents duplicate relationships.
model merchant_retailers {
  id         String                 @id @default(cuid())
  merchantId String
  retailerId String
  /// Status of the merchant-retailer relationship
  status     MerchantRetailerStatus @default(ACTIVE)
  createdAt  DateTime               @default(now())
  createdBy  String?
  updatedAt  DateTime               @updatedAt

  /// Listing status for consumer visibility (paid entitlement).
  /// Consumer visibility = retailers.visibilityStatus=ELIGIBLE AND listingStatus=LISTED AND status=ACTIVE
  listingStatus  MerchantRetailerListingStatus @default(UNLISTED)
  /// When retailer was listed (paid entitlement activated)
  listedAt       DateTime?
  /// Who listed the retailer (admin user ID or 'system' for auto)
  listedBy       String?
  /// When retailer was unlisted
  unlistedAt     DateTime?
  /// Who unlisted the retailer
  unlistedBy     String?
  /// Reason for unlisting (billing_delinquent, manual, policy_violation, etc.)
  unlistedReason String?

  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, retailerId])
  @@index([merchantId])
  @@index([retailerId])
  @@index([status])
  @@index([listingStatus])
}

/// Per-retailer permissions for merchant users.
/// Per Merchant-and-Retailer-Reference: Permissions are per Retailer, explicit and auditable.
model merchant_user_retailers {
  id                 String               @id @default(cuid())
  merchantUserId     String
  merchantRetailerId String
  /// Role for this user on this specific retailer
  role               MerchantRetailerRole @default(VIEWER)
  createdAt          DateTime             @default(now())
  createdBy          String?
  updatedAt          DateTime             @updatedAt

  merchant_users     merchant_users     @relation(fields: [merchantUserId], references: [id], onDelete: Cascade)
  merchant_retailers merchant_retailers @relation(fields: [merchantRetailerId], references: [id], onDelete: Cascade)

  @@unique([merchantUserId, merchantRetailerId])
  @@index([merchantUserId])
  @@index([merchantRetailerId])
}

model execution_logs {
  id          String     @id @default(cuid())
  executionId String
  level       LogLevel   @default(INFO)
  event       String
  message     String
  metadata    Json?
  timestamp   DateTime   @default(now())
  executions  executions @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([event])
  @@index([executionId])
  @@index([level])
}

model executions {
  id            String          @id @default(cuid())
  sourceId      String
  status        ExecutionStatus @default(PENDING)
  startedAt     DateTime        @default(now())
  completedAt   DateTime?
  duration      Int?
  itemsFound    Int             @default(0)
  itemsUpserted Int             @default(0)
  errorMessage  String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt     DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy     String?
  /// Reason for ignoring (e.g., 'bad_scrape_data', 'duplicate_run', 'test_run')
  ignoredReason String?

  execution_logs execution_logs[]
  sources        sources          @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([ignoredAt])
}

model feed_corrections {
  id                  String               @id @default(cuid())
  retailerId          String
  feedId              String
  quarantinedRecordId String?
  recordRef           String
  field               String
  oldValue            String?
  newValue            String
  createdBy           String
  createdAt           DateTime             @default(now())
  retailer_feeds      retailer_feeds       @relation(fields: [feedId], references: [id], onDelete: Cascade)
  quarantined_records quarantined_records? @relation(fields: [quarantinedRecordId], references: [id])

  @@index([retailerId])
  @@index([feedId, recordRef])
  @@index([quarantinedRecordId])
}

model market_reports {
  id          String   @id @default(cuid())
  productId   String?
  category    String
  reportType  String
  data        Json
  generatedAt DateTime @default(now())
}

model pixel_events {
  id            String    @id @default(cuid())
  merchantId    String
  orderId       String
  orderValue    Decimal   @db.Decimal(10, 2)
  orderCurrency String    @default("USD")
  skuList       Json?
  clickEventId  String?
  attributedAt  DateTime?
  userAgent     String?
  ipHash        String?
  referrer      String?
  createdAt     DateTime  @default(now())
  merchants     merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([merchantId])
  @@index([orderId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// Per ADR-015: Price history is append-only. Provenance fields enable corrections.
model prices {
  id                  String     @id @default(cuid())
  productId           String?
  retailerId          String
  merchantId          String?
  sourceId            String?
  price               Decimal    @db.Decimal(10, 2)
  currency            String     @default("USD")
  url                 String
  inStock             Boolean    @default(true)
  createdAt           DateTime   @default(now())
  /// ADR-015: When the price was observed at the source (not when written to DB)
  /// This is the canonical timestamp for correction matching and provenance
  observedAt          DateTime   @default(now())
  freeShippingMinimum Decimal?   @db.Decimal(10, 2)
  shippingCost        Decimal?   @db.Decimal(10, 2)
  shippingNotes       String?
  originalPrice       Decimal?   @db.Decimal(10, 2)
  priceType           PriceType?
  saleStartsAt        DateTime?
  saleEndsAt          DateTime?
  affiliateFeedRunId  String?
  priceSignatureHash  String?
  sourceProductId     String?

  /// ADR-015 Provenance: Type of ingestion run that created this price
  ingestionRunType IngestionRunType?
  /// ADR-015 Provenance: ID of the specific run (execution, affiliate_feed_run, retailer_feed_run)
  ingestionRunId   String?
  /// ADR-015 Provenance: Affiliate network ID if from affiliate feed
  affiliateId      String?

  affiliate_feed_runs affiliate_feed_runs? @relation(fields: [affiliateFeedRunId], references: [id])
  products            products?            @relation(fields: [productId], references: [id], onDelete: Cascade)
  retailers           retailers            @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchants           merchants?           @relation(fields: [merchantId], references: [id], onDelete: SetNull)
  sources             sources?             @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  source_products     source_products?     @relation(fields: [sourceProductId], references: [id])
  product_reports     product_reports[]

  @@index([inStock])
  @@index([productId])
  @@index([retailerId])
  @@index([sourceProductId])
  @@index([merchantId])
  @@index([sourceId])
  @@index([ingestionRunType])
  @@index([ingestionRunId])
  @@index([observedAt])
}

// DELETED: pricing_snapshots model (benchmark subsystem removed for v1)

/// ADR-015: Corrections overlay for price history.
/// Corrections are explicit, auditable overlays that modify how facts are interpreted.
/// Facts (prices, pricing_snapshots) are never mutated; corrections change visibility/value at read time.
model price_corrections {
  id String @id @default(cuid())

  /// Scope type determines what entity the correction applies to
  scopeType PriceCorrectionScopeType
  /// ID of the scoped entity (productId, retailerId, merchantId, sourceId, affiliateId, or runId)
  scopeId   String

  /// Time window for the correction (observedAt must be in [startTs, endTs))
  startTs DateTime
  endTs   DateTime

  /// What action to take
  action PriceCorrectionAction

  /// Value for MULTIPLIER action (e.g., 0.9 for 10% discount correction)
  /// Must be NULL for IGNORE action
  value Decimal? @db.Decimal(10, 4)

  /// Human-readable reason for the correction
  reason String

  /// Audit fields for creation
  createdAt DateTime @default(now())
  createdBy String

  /// Soft-revoke fields - corrections are never deleted
  revokedAt    DateTime?
  revokedBy    String?
  revokeReason String?

  @@index([scopeType, scopeId])
  @@index([startTs, endTs])
  @@index([revokedAt])
  @@index([createdAt])
}

model product_reports {
  id          String           @id @default(cuid())
  productId   String
  userId      String?
  priceId     String?
  issueType   ProductIssueType
  description String
  status      ReportStatus     @default(PENDING)
  reviewedBy  String?
  reviewNotes String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  resolvedAt  DateTime?
  prices      prices?          @relation(fields: [priceId], references: [id])
  products    products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users       users?           @relation(fields: [userId], references: [id])
}

model products {
  id                    String                 @id @default(cuid())
  name                  String
  description           String?
  category              String
  brand                 String?
  imageUrl              String?
  upc                   String?                @unique
  caliber               String?
  grainWeight           Int?
  caseMaterial          String?
  purpose               String?
  roundCount            Int?
  metadata              Json?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  embedding             Unsupported("vector")?
  barrelLengthReference Decimal?               @db.Decimal(4, 2)
  bulletType            BulletType?
  controlledExpansion   Boolean?
  dataConfidence        Decimal?               @db.Decimal(3, 2)
  dataSource            DataSource?            @default(UNKNOWN)
  factoryNew            Boolean?               @default(true)
  isSubsonic            Boolean?
  lowFlash              Boolean?
  lowRecoil             Boolean?
  matchGrade            Boolean?
  muzzleVelocityFps     Int?
  pressureRating        PressureRating?        @default(STANDARD)
  shortBarrelOptimized  Boolean?
  suppressorSafe        Boolean?

  // ═══════════════════════════════════════════════════════════════════════════
  // Product Resolver fields (Spec v1.2 §0.1)
  // ═══════════════════════════════════════════════════════════════════════════

  /// Immutable canonical key for product identity. Format: "UPC:<upcNorm>" or "FP:<hash>"
  /// Per Spec v1.2: MUST NOT change after creation.
  canonicalKey          String?                @unique
  /// Normalized UPC (12-digit, no check digit issues). Immutable after creation.
  upcNorm               String?                @unique
  /// Normalized brand name for fingerprint matching
  brandNorm             String?
  /// Normalized caliber for fingerprint matching
  caliberNorm           String?
  /// Additive-only product specifications (grain, packCount, etc.)
  specs                 Json?

  // Relations
  alerts                alerts[]
  prices                prices[]
  product_reports       product_reports[]
  source_products       source_products[]
  watchlist_items       watchlist_items[]
  product_links                 product_links[]
  aliasesFrom                   product_aliases[]      @relation("AliasFrom")
  aliasesTo                     product_aliases[]      @relation("AliasTo")
  product_resolve_requests      product_resolve_requests[]

  @@index([bulletType])
  @@index([caliber])
  @@index([isSubsonic])
  @@index([pressureRating])
  @@index([purpose])
  @@index([brandNorm, caliberNorm])
}

model quarantined_records {
  id               String             @id @default(cuid())
  retailerId       String
  feedId           String
  runId            String?
  productType      String?
  matchKey         String
  rawData          Json
  parsedFields     Json?
  blockingErrors   Json
  status           QuarantineStatus   @default(QUARANTINED)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  feed_corrections feed_corrections[]
  retailer_feeds   retailer_feeds     @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@unique([feedId, matchKey])
  @@index([retailerId])
  @@index([feedId, status])
  @@index([status])
}

model retailers {
  id        String       @id @default(cuid())
  name      String
  website   String       @unique
  logoUrl   String?
  tier      RetailerTier @default(STANDARD)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  /// Consumer visibility state per ADR-005.
  /// ELIGIBLE = visible in consumer search, alerts, watchlists
  /// INELIGIBLE = hidden from consumers (policy, data quality, etc.)
  /// SUSPENDED = explicit block, under review
  visibilityStatus    RetailerVisibility @default(ELIGIBLE)
  visibilityReason    String?
  visibilityUpdatedAt DateTime?
  visibilityUpdatedBy String?

  prices             prices[]
  sources            sources[]
  subscriptions      subscriptions[]
  merchant_retailers merchant_retailers[]
  retailer_feeds     retailer_feeds[]
  retailer_skus      retailer_skus[]

  @@index([visibilityStatus])
}

model source_product_presence {
  id                String          @id @default(cuid())
  sourceProductId   String          @unique
  lastSeenAt        DateTime
  lastSeenSuccessAt DateTime?
  updatedAt         DateTime        @updatedAt
  source_products   source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  @@index([lastSeenSuccessAt])
}

model source_product_seen {
  id                  String              @id @default(cuid())
  runId               String
  sourceProductId     String
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)
  source_products     source_products     @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  @@unique([runId, sourceProductId])
  @@index([runId])
}

/// One row per product per source. Contains product attributes.
/// Identifiers now live in source_product_identifiers child table.
/// Identity mapping lives in product_links table (Spec v1.2).
model source_products {
  id                      String                    @id @default(cuid())
  sourceId                String

  // Product attributes
  title                   String
  url                     String
  imageUrl                String?
  brand                   String?
  description             String?
  category                String?
  caliber                 String?
  grainWeight             Int?
  roundCount              Int?
  normalizedUrl           String?

  // Legacy: Direct product linkage (deprecated, use product_links instead)
  // Kept for backward compatibility during migration
  productId               String?

  // Run tracking
  createdByRunId          String?
  lastUpdatedByRunId      String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt

  // ═══════════════════════════════════════════════════════════════════════════
  // Product Resolver fields (Spec v1.2 §0.1)
  // ═══════════════════════════════════════════════════════════════════════════

  /// Hash of normalized input fields for reconciliation trigger detection.
  /// Per Spec v1.2 §6: Resolver compares this against prior inputHash.
  normalizedHash          String?

  /// Canonical identity key for this source product.
  /// Namespaced string: "upc:12345678901", "sku:ABC123", "urlhash:deadbeef"
  /// Precedence: UPC > SKU > URL hash. Used for idempotency and dedup.
  identityKey             String?

  // Relations
  prices                        prices[]
  source_product_presence       source_product_presence?
  source_product_seen           source_product_seen[]
  source_product_identifiers    source_product_identifiers[]
  sources                       sources                   @relation(fields: [sourceId], references: [id])
  products                      products?                 @relation(fields: [productId], references: [id])
  product_links                 product_links?
  product_resolve_requests      product_resolve_requests[]

  @@index([productId])
  @@index([sourceId])
  @@index([normalizedHash])
  @@index([identityKey]) // For dedupe and idempotency lookups
}

/// All identifiers observed for a source product.
/// Supports multiple identifier types per product (SKU, UPC, network IDs, etc.)
/// One identifier is marked canonical for upsert/dedupe purposes.
model source_product_identifiers {
  id              String         @id @default(cuid())
  sourceProductId String
  idType          IdentifierType
  idValue         String
  /// Namespace for scoping: network name (IMPACT, AVANTLINK), retailer ID, etc.
  /// Required for NETWORK_ITEM_ID, MERCHANT_SKU. Empty string for universal codes (UPC, EAN).
  namespace       String         @default("")
  /// Exactly one identifier per source_product should be canonical (used for upsert matching)
  isCanonical     Boolean        @default(false)
  /// Normalized value for consistent matching (trimmed, uppercased where appropriate)
  normalizedValue String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  source_products source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  // Unique: same identifier can't appear twice for same product
  @@unique([sourceProductId, idType, idValue, namespace], name: "source_product_identifiers_unique")
  // Fast lookup by identifier (for find-by-any-identifier upsert)
  @@index([idType, idValue, namespace], name: "source_product_identifiers_lookup")
  // Find canonical identifier for a product
  @@index([sourceProductId, isCanonical], name: "source_product_identifiers_canonical")
}

// ═══════════════════════════════════════════════════════════════════════════════
// Product Resolver Tables (Spec v1.2)
// ═══════════════════════════════════════════════════════════════════════════════

/// Product Resolver control plane. Stores all identity decisions.
/// This is the source of truth for source_product → product linkage.
/// Per Spec v1.2 §0.0: All product grouping MUST join through this table.
model product_links {
  id              String                  @id @default(cuid())
  sourceProductId String                  @unique
  productId       String?

  /// How the link was established
  matchType       ProductLinkMatchType
  /// Current resolution status
  status          ProductLinkStatus
  /// Why resolution resulted in UNMATCHED or ERROR (null for MATCHED/CREATED)
  reasonCode      ProductLinkReasonCode?
  /// Match confidence score (0.0-1.0), deterministic
  confidence      Decimal                 @db.Decimal(5, 4)
  /// Resolver version that made this decision
  resolverVersion String

  /// Full audit trail: inputNormalized, inputHash, dictionaryVersion,
  /// trustConfigVersion, rulesFired, candidates, previousDecision (if relink)
  evidence        Json

  /// When resolver logic last ran (not just row update)
  resolvedAt      DateTime?
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt

  // Relations
  source_products source_products         @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)
  products        products?               @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([productId])
  @@index([status])
  @@index([matchType])
  @@index([status, matchType]) // For filtered queries by resolution state
  @@index([resolverVersion])
  @@index([resolvedAt])
}

/// Alias mapping for canonical product merges.
/// Allows product consolidation without rewriting history.
/// Per Spec v1.2 §0.1: Resolver MUST resolve through aliases before persisting links.
model product_aliases {
  id            String   @id @default(cuid())
  /// Product being aliased (merged away)
  fromProductId String   @unique
  /// Target product (winner of merge)
  toProductId   String
  /// Why the merge happened
  reason        String
  createdAt     DateTime @default(now())
  createdBy     String?

  // Relations - both point to products table
  // Note: fromProduct is the "loser" that should not be used directly
  fromProduct   products @relation("AliasFrom", fields: [fromProductId], references: [id], onDelete: Restrict)
  toProduct     products @relation("AliasTo", fields: [toProductId], references: [id], onDelete: Restrict)

  @@index([toProductId])
}

/// Tracks product resolution requests for intent, dedup, and retries.
/// Separate from product_links (which tracks outcomes).
/// Per Spec: idempotencyKey = sourceId + ":" + identityKey
model product_resolve_requests {
  id              String                       @id @default(cuid())

  /// sourceId + ":" + identityKey (e.g., "src123:upc:012345678901")
  idempotencyKey  String                       @unique
  sourceProductId String
  sourceId        String

  /// Current status of this request
  status          ProductResolveRequestStatus  @default(PENDING)

  /// Number of processing attempts
  attempts        Int                          @default(0)
  /// Last attempt timestamp
  lastAttemptAt   DateTime?
  /// Error message if FAILED
  errorMessage    String?

  /// Resulting productId if created/matched (denormalized for quick lookup)
  resultProductId String?

  createdAt       DateTime                     @default(now())
  updatedAt       DateTime                     @updatedAt

  // Relations
  source_products source_products              @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)
  sources         sources                      @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  products        products?                    @relation(fields: [resultProductId], references: [id], onDelete: SetNull)

  @@index([sourceProductId])
  @@index([sourceId])
  @@index([status])
  @@index([createdAt])
  @@index([status, updatedAt]) // For worker polling queries
}

/// Per-source trust configuration for identifier eligibility.
/// Per Spec v1.2 §0.1: Resolver uses this to determine if UPC is trusted.
model source_trust_config {
  id         String   @id @default(cuid())
  sourceId   String   @unique
  /// Whether UPC codes from this source are trusted for canonical matching
  upcTrusted Boolean  @default(false)
  /// Config version, incremented on every change, recorded in link evidence
  version    Int      @default(1)
  updatedAt  DateTime @updatedAt
  updatedBy  String?

  sources    sources  @relation(fields: [sourceId], references: [id], onDelete: Cascade)
}

model sources {
  id                        String            @id @default(cuid())
  name                      String
  url                       String
  type                      SourceType        @default(HTML)
  enabled                   Boolean           @default(true)
  interval                  Int               @default(3600)
  lastRunAt                 DateTime?
  paginationConfig          Json?
  affiliateNetwork          AffiliateNetwork?
  feedHash                  String?
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  retailerId                String
  affiliateAccountId        String?
  affiliateAccountName      String?
  affiliateAdvertiserId     String?
  affiliateCampaignId       String?
  affiliateProgramId        String?
  affiliateTrackingTemplate String?
  isDisplayPrimary          Boolean           @default(false)
  sourceKind                SourceKind        @default(DIRECT)
  affiliate_feeds           affiliate_feeds[]
  executions                executions[]
  source_products           source_products[]
  prices                    prices[]
  retailers                 retailers             @relation(fields: [retailerId], references: [id])
  source_trust_config       source_trust_config?
  product_resolve_requests  product_resolve_requests[]

  @@index([retailerId], map: "sources_retailer_id_idx")
}

model subscriptions {
  id         String             @id @default(cuid())
  userId     String?
  retailerId String?
  type       SubscriptionType
  status     SubscriptionStatus @default(ACTIVE)
  startDate  DateTime           @default(now())
  endDate    DateTime?
  amount     Decimal            @db.Decimal(10, 2)
  currency   String             @default("USD")
  stripeId   String?            @unique
  retailers  retailers?         @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  users      users?             @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model system_settings {
  key         String   @id @default(cuid())
  value       Json
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
}

model users {
  id                    String                  @id @default(cuid())
  email                 String                  @unique
  name                  String?
  image                 String?
  password              String?
  emailVerified         DateTime?
  tier                  UserTier                @default(FREE)
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  deletionRequestedAt   DateTime?
  deletionScheduledFor  DateTime?
  status                UserStatus              @default(ACTIVE)
  Account               Account[]
  Session               Session[]
  alerts                alerts[]
  data_subscriptions    data_subscriptions[]
  product_reports       product_reports[]
  subscriptions         subscriptions[]
  watchlist_collections watchlist_collections[]
  watchlist_items       watchlist_items[]
}

model watchlist_collections {
  id              String            @id @default(cuid())
  userId          String
  name            String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  users           users             @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items[]

  @@index([userId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// ADR-011A: Intent-Ready Saved Items (WatchlistItem Resolver Seam)
/// Supports SKU intent (v1) with schema-level preparation for future SEARCH intent.
/// See context/decisions/ADR-017-Intent-Ready-Saved-Items.md for full specification.
model watchlist_items {
  id           String   @id @default(cuid())
  userId       String
  productId    String? /// Nullable for future SEARCH intent; v1 enforces non-null for SKU
  collectionId String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  /// ADR-011A: Intent-ready fields
  intentType    String    @default("SKU") @map("intent_type")
  querySnapshot Json?     @map("query_snapshot") /// For future SEARCH intent
  deletedAt     DateTime? @map("deleted_at") /// Soft delete timestamp

  /// Notification preferences (per ADR-011)
  notificationsEnabled    Boolean   @default(true)
  priceDropEnabled        Boolean   @default(true)
  backInStockEnabled      Boolean   @default(true)
  minDropPercent          Int       @default(5)
  minDropAmount           Decimal   @default(5.0) @db.Decimal(10, 2)
  stockAlertCooldownHours Int       @default(24)
  lastStockNotifiedAt     DateTime?
  lastPriceNotifiedAt     DateTime?

  /// Two-phase notification claim fields (prevents duplicate sends under concurrency)
  /// Claim is stale after 5 minutes (allows retry if worker crashes)
  priceNotificationClaimedAt DateTime? @map("price_notification_claimed_at")
  priceNotificationClaimKey  String?   @map("price_notification_claim_key")
  stockNotificationClaimedAt DateTime? @map("stock_notification_claimed_at")
  stockNotificationClaimKey  String?   @map("stock_notification_claim_key")

  /// Relations
  alerts                alerts[]
  watchlist_collections watchlist_collections? @relation(fields: [collectionId], references: [id])
  products              products?              @relation(fields: [productId], references: [id], onDelete: Cascade)
  users                 users                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Note: Uniqueness for active SKU items enforced by PARTIAL unique index in migration:
  // CREATE UNIQUE INDEX watchlist_items_sku_active_uniq ON watchlist_items (user_id, product_id)
  //   WHERE intent_type = 'SKU' AND deleted_at IS NULL AND product_id IS NOT NULL;
  // Prisma doesn't support partial indexes in schema, so this is managed via raw SQL migration.
  // See ADR-011A Section 19.1
  @@index([collectionId])
  @@index([productId])
  @@index([userId])
  @@index([deletedAt], map: "watchlist_items_deleted_at_idx")
  @@index([intentType], map: "watchlist_items_intent_type_idx")
}

enum AdType {
  DISPLAY
  SPONSORED_PRODUCT
  BANNER
}

enum AffiliateFeedRunStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

enum AffiliateFeedRunTrigger {
  SCHEDULED
  MANUAL
  MANUAL_PENDING
  ADMIN_TEST
  RETRY
}

enum AffiliateFeedStatus {
  DRAFT
  ENABLED
  PAUSED
  DISABLED
}

enum AffiliateNetwork {
  IMPACT
  AVANTLINK
  SHAREASALE
  CJ
  RAKUTEN
}

enum AlertRuleType {
  PRICE_DROP
  BACK_IN_STOCK
}

enum AlertType {
  PRICE_DROP
  BACK_IN_STOCK
  NEW_PRODUCT
}

// DELETED: BenchmarkConfidence enum (benchmark subsystem removed for v1)
// DELETED: BenchmarkSource enum (benchmark subsystem removed for v1)

enum BulletType {
  JHP
  HP
  BJHP
  XTP
  HST
  GDHP
  VMAX
  FMJ
  TMJ
  CMJ
  MC
  BALL
  SP
  JSP
  PSP
  RN
  FPRN
  FRANGIBLE
  AP
  TRACER
  BLANK
  WADCUTTER
  SWC
  LSWC
  BUCKSHOT
  BIRDSHOT
  SLUG
  OTHER
}

enum DaaSPlan {
  BASIC
  PROFESSIONAL
  ENTERPRISE
}

enum DataSource {
  MANUFACTURER
  RETAILER_FEED
  PARSED
  MANUAL
  AI_INFERRED
  UNKNOWN
}

enum MerchantContactRole {
  PRIMARY
  BILLING
  TECHNICAL
  MARKETING
  OTHER
}

enum MerchantPaymentMethod {
  STRIPE
  PURCHASE_ORDER
}

enum MerchantStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum MerchantSubscriptionStatus {
  ACTIVE
  EXPIRED
  SUSPENDED
  CANCELLED
}

enum MerchantTier {
  FOUNDING
  BASIC
  PRO
  ENTERPRISE
}

enum MerchantUserRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

/// Status of a merchant-retailer relationship
enum MerchantRetailerStatus {
  /// Active relationship, merchant can manage retailer
  ACTIVE
  /// Relationship pending approval
  PENDING
  /// Relationship suspended
  SUSPENDED
  /// Relationship terminated
  INACTIVE
}

/// Listing status for consumer visibility (paid entitlement).
/// Per Merchant-and-Retailer-Reference: Merchant pays to list each retailer.
enum MerchantRetailerListingStatus {
  /// Retailer is listed and visible to consumers (if also ELIGIBLE)
  LISTED
  /// Retailer is unlisted, hidden from consumers
  UNLISTED
}

/// Role for a merchant user on a specific retailer
enum MerchantRetailerRole {
  /// Full access to retailer management
  ADMIN
  /// Can edit feeds and data
  EDITOR
  /// Read-only access
  VIEWER
}

/// ADR-015: Type of ingestion run for price provenance tracking
enum IngestionRunType {
  /// Scraped from retailer website via executions
  SCRAPE
  /// From affiliate feed via affiliate_feed_runs
  AFFILIATE_FEED
  /// From merchant portal feed via retailer_feed_runs (legacy: dealer_feed_runs)
  RETAILER_FEED
  /// Manual entry or import
  MANUAL
}

/// ADR-015: Scope types for price corrections
/// Precedence: PRODUCT > RETAILER > MERCHANT > SOURCE > AFFILIATE > FEED_RUN
enum PriceCorrectionScopeType {
  /// Correction applies to a specific product
  PRODUCT
  /// Correction applies to all prices from a retailer
  RETAILER
  /// Correction applies to all prices from a merchant
  MERCHANT
  /// Correction applies to all prices from a source
  SOURCE
  /// Correction applies to all prices from an affiliate
  AFFILIATE
  /// Correction applies to all prices from a specific feed run
  FEED_RUN
}

/// ADR-015: Actions for price corrections
enum PriceCorrectionAction {
  /// Exclude matching prices from all user-visible queries
  IGNORE
  /// Apply a multiplier to matching prices (visible_price = raw_price * value)
  MULTIPLIER
}

enum ExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum FeedAccessType {
  URL
  AUTH_URL
  FTP
  SFTP
  UPLOAD
}

enum FeedCompression {
  NONE
  GZIP
}

enum FeedFormat {
  CSV
}

/// Feed variant for supporting multiple feeds per source
/// Used with affiliate_feeds to distinguish full vs delta, regional splits, etc.
enum FeedVariant {
  FULL // Complete catalog refresh
  DELTA // Incremental updates only
  REGIONAL_US // US-specific catalog
  REGIONAL_CA // Canada-specific catalog
  REGIONAL_EU // EU-specific catalog
  CATEGORY_AMMO // Ammo-only feed
  CATEGORY_ACCESSORIES // Accessories-only feed
}

enum FeedFormatType {
  GENERIC
  AMMOSEEK_V1
  GUNENGINE_V2
  IMPACT
}

enum FeedRunStatus {
  RUNNING
  SUCCESS
  WARNING
  FAILURE
  PENDING
  SKIPPED
}

enum FeedStatus {
  PENDING
  HEALTHY
  WARNING
  FAILED
}

enum FeedTransport {
  FTP
  SFTP
}

// DELETED: InsightConfidence enum (benchmark subsystem removed for v1)
// DELETED: InsightType enum (benchmark subsystem removed for v1)

enum LogLevel {
  INFO
  WARN
  ERROR
}

// DELETED: MappingConfidence enum (benchmark subsystem removed for v1)

enum PressureRating {
  STANDARD
  PLUS_P
  PLUS_P_PLUS
  NATO
  UNKNOWN
}

enum PriceType {
  REGULAR
  SALE
  CLEARANCE
}

enum ProductIssueType {
  INCORRECT_PRICE
  OUT_OF_STOCK
  INCORRECT_INFO
  BROKEN_LINK
  WRONG_PRODUCT
  SPAM
  OTHER
}

enum QuarantineStatus {
  QUARANTINED
  RESOLVED
  DISMISSED
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum RetailerTier {
  STANDARD
  PREMIUM
}

/// Retailer visibility state for consumer-facing queries.
/// Per ADR-005: Eligibility applies to Retailer visibility only.
/// This is the authoritative source for consumer visibility filtering.
enum RetailerVisibility {
  /// Retailer is visible in consumer search, alerts, watchlists
  ELIGIBLE
  /// Retailer is hidden from consumers (policy, data quality, etc.)
  INELIGIBLE
  /// Retailer is suspended (explicit block, under review)
  SUSPENDED
}

enum ShippingType {
  FLAT
  PER_UNIT
  CALCULATED
  FREE
  UNKNOWN
}

enum SourceKind {
  DIRECT
  AFFILIATE_FEED
  OTHER
}

/// Comprehensive identifier types for source_product_identifiers
/// Supports all affiliate networks, retailer feeds, and standard product codes
enum IdentifierType {
  // Standard product codes
  SKU           // Retailer-specific stock keeping unit
  UPC           // Universal Product Code (12-digit)
  EAN           // European Article Number (13-digit)
  GTIN          // Global Trade Item Number (8, 12, 13, or 14 digit)
  MPN           // Manufacturer Part Number
  ASIN          // Amazon Standard Identification Number

  // URL-based identifiers
  URL           // Canonical product URL
  URL_HASH      // Hash of normalized URL (fallback identity)

  // Network-specific identifiers (use with namespace)
  NETWORK_ITEM_ID   // Affiliate network's item ID (namespace: IMPACT, AVANTLINK, etc.)
  MERCHANT_SKU      // Merchant-provided SKU (namespace: retailer ID)

  // Internal identifiers
  INTERNAL_ID       // IronScout-generated identifier
}

enum SourceType {
  HTML
  JS_RENDERED
  RSS
  JSON
  FEED_CSV
  FEED_XML
  FEED_JSON
}

enum StoreType {
  ONLINE_ONLY
  RETAIL_AND_ONLINE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum SubscriptionType {
  USER_PREMIUM
  RETAILER_PREMIUM
}

enum TestRunStatus {
  PASS
  WARN
  FAIL
}

enum UserStatus {
  ACTIVE
  PENDING_DELETION
  DELETED
}

enum UserTier {
  FREE
  PREMIUM
}

// ═══════════════════════════════════════════════════════════════════════════════
// Product Resolver Enums (Spec v1.2)
// ═══════════════════════════════════════════════════════════════════════════════

/// Match type for product_links. Determines how a source_product was linked to a canonical product.
enum ProductLinkMatchType {
  /// Matched via trusted UPC code
  UPC
  /// Matched via fingerprint scoring (brand, caliber, pack, grain, title)
  FINGERPRINT
  /// Manually linked by admin/operator
  MANUAL
  /// No match found (data insufficient or ambiguous)
  NONE
  /// Resolution failed with system error
  ERROR
}

/// Status of a product_links resolution.
enum ProductLinkStatus {
  /// Linked to existing canonical product
  MATCHED
  /// Created new canonical product and linked
  CREATED
  /// @deprecated Use NEEDS_REVIEW instead. Kept for backward compatibility with existing data.
  /// Will be migrated to NEEDS_REVIEW in future cleanup.
  UNMATCHED
  /// Awaiting human review (insufficient data, ambiguous match, or flagged)
  /// This is the correct terminal state for "could not decide" cases.
  NEEDS_REVIEW
  /// Manually skipped by admin during review (deferred, not actionable, etc.)
  /// Terminal state - removed from active review queue.
  SKIPPED
  /// Resolution failed with system error
  ERROR
}

/// Reason codes for UNMATCHED or ERROR status in product_links.
enum ProductLinkReasonCode {
  /// Missing required fields for any match strategy
  INSUFFICIENT_DATA
  /// UPC present but invalid format
  INVALID_UPC
  /// UPC present but source is not trusted for UPC
  UPC_NOT_TRUSTED
  /// Fingerprint score in ambiguous range or too close to second-best
  AMBIGUOUS_FINGERPRINT
  /// Match candidate has conflicting immutable identifiers
  CONFLICTING_IDENTIFIERS
  /// Existing link is MANUAL and cannot be overridden
  MANUAL_LOCKED
  /// Relink blocked by hysteresis (confidence delta too small)
  RELINK_BLOCKED_HYSTERESIS
  /// System error during resolution (DB, timeout, etc.)
  SYSTEM_ERROR
  /// All normalization attempts failed
  NORMALIZATION_FAILED
}

/// Status of a product resolve request.
enum ProductResolveRequestStatus {
  /// Queued, waiting to be processed
  PENDING
  /// Currently being processed
  PROCESSING
  /// Successfully resolved (see product_links for outcome)
  COMPLETED
  /// Failed to process (see errorMessage)
  FAILED
}
