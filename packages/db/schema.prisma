generator client {
  provider        = "prisma-client-js"
  output          = "./generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  users             users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  users        users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model admin_audit_logs {
  id          String   @id @default(cuid())
  adminUserId String
  merchantId  String?
  action      String
  resource    String?
  resourceId  String?
  oldValue    Json?
  newValue    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([action])
  @@index([adminUserId])
  @@index([createdAt])
  @@index([merchantId])
}

model advertisements {
  id          String   @id @default(cuid())
  title       String
  description String
  imageUrl    String?
  targetUrl   String
  adType      AdType   @default(DISPLAY)
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model affiliate_feed_run_errors {
  id                  String              @id @default(cuid())
  runId               String
  code                String
  message             String
  rowNumber           Int?
  sample              Json?
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model affiliate_feed_runs {
  id                        String                      @id @default(cuid())
  feedId                    String
  sourceId                  String
  trigger                   AffiliateFeedRunTrigger     @default(SCHEDULED)
  status                    AffiliateFeedRunStatus      @default(RUNNING)
  startedAt                 DateTime                    @default(now())
  finishedAt                DateTime?
  durationMs                Int?
  downloadBytes             BigInt?
  rowsRead                  Int?
  rowsParsed                Int?
  productsUpserted          Int?
  pricesWritten             Int?
  productsPromoted          Int?
  errorCount                Int?
  productsExpired           Int?
  productsRejected          Int?
  duplicateKeyCount         Int?
  urlHashFallbackCount      Int?
  activeCountBefore         Int?
  seenSuccessCount          Int?
  wouldExpireCount          Int?
  skippedReason             String?
  failureKind               String?
  failureCode               String?
  failureMessage            String?
  isPartial                 Boolean                     @default(false)
  expiryStepFailed          Boolean                     @default(false)
  expiryBlocked             Boolean                     @default(false)
  expiryBlockedReason       String?
  expiryApprovedAt          DateTime?
  expiryApprovedBy          String?
  artifactUrl               String?
  correlationId             String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt                 DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy                 String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason             String?

  affiliate_feed_run_errors affiliate_feed_run_errors[]
  affiliate_feeds           affiliate_feeds             @relation(fields: [feedId], references: [id], onDelete: Cascade)
  prices                    prices[]
  source_product_seen       source_product_seen[]

  @@index([feedId, startedAt])
  @@index([feedId, status, startedAt])
  @@index([feedId, trigger, startedAt])
  @@index([ignoredAt])
}

model affiliate_feeds {
  id                     String                @id @default(cuid())
  sourceId               String                @unique
  network                AffiliateNetwork
  status                 AffiliateFeedStatus   @default(DRAFT)
  scheduleFrequencyHours Int?
  nextRunAt              DateTime?
  expiryHours            Int                   @default(48)
  consecutiveFailures    Int                   @default(0)
  lastRunAt              DateTime?
  manualRunPending       Boolean               @default(false)
  transport              FeedTransport         @default(SFTP)
  host                   String?
  port                   Int?
  path                   String?
  username               String?
  secretCiphertext       Bytes?
  secretKeyId            String?
  secretVersion          Int                   @default(1)
  format                 FeedFormat            @default(CSV)
  compression            FeedCompression       @default(NONE)
  lastRemoteMtime        DateTime?
  lastRemoteSize         BigInt?
  lastContentHash        String?
  maxFileSizeBytes       BigInt?
  maxRowCount            Int?
  feedLockId             BigInt                @unique @default(autoincrement())
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  createdBy              String?
  affiliate_feed_runs    affiliate_feed_runs[]
  sources                sources               @relation(fields: [sourceId], references: [id])

  @@index([nextRunAt])
  @@index([status])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model alerts {
  id              String           @id @default(cuid())
  userId          String
  productId       String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  watchlistItemId String?
  ruleType        AlertRuleType?
  isEnabled       Boolean          @default(true)

  /// ADR-015: Alert suppression for retroactive correction handling
  /// When set, alert is hidden in UI and never re-fired
  suppressedAt     DateTime?
  /// Who suppressed the alert (admin user ID or 'system')
  suppressedBy     String?
  /// Reason for suppression (e.g., 'run_ignored', 'correction_applied')
  suppressedReason String?

  products        products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users           users            @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items? @relation(fields: [watchlistItemId], references: [id], onDelete: Cascade)

  @@unique([userId, productId, ruleType], map: "alerts_userid_productid_ruletype_key")
  @@index([productId])
  @@index([userId])
  @@index([suppressedAt])
  @@index([watchlistItemId])
}

model benchmarks {
  id             String              @id @default(cuid())
  canonicalSkuId String              @unique
  medianPrice    Decimal             @db.Decimal(10, 2)
  minPrice       Decimal             @db.Decimal(10, 2)
  maxPrice       Decimal             @db.Decimal(10, 2)
  avgPrice       Decimal?            @db.Decimal(10, 2)
  sellerCount    Int
  source         BenchmarkSource
  confidence     BenchmarkConfidence
  dataPoints     Int                 @default(0)
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  canonical_skus canonical_skus      @relation(fields: [canonicalSkuId], references: [id], onDelete: Cascade)
}

model canonical_skus {
  id                  String                @id @default(cuid())
  upc                 String?               @unique
  caliber             String
  grain               Int
  caseType            String?
  bulletType          String?
  brand               String
  packSize            Int
  name                String
  imageUrl            String?
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  productId           String?
  benchmarks          benchmarks?
  products            products?             @relation(fields: [productId], references: [id])
  retailer_skus       retailer_skus[]
  pricing_snapshots   pricing_snapshots[]
  product_suggestions product_suggestions[]

  @@index([caliber, grain, brand, packSize])
  @@index([upc])
}

model click_events {
  id             String    @id @default(cuid())
  merchantId     String
  retailerSkuId  String?
  canonicalSkuId String?
  sessionId      String?
  userAgent      String?
  ipHash         String?
  referrer       String?
  createdAt      DateTime  @default(now())
  merchants      merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([merchantId])
  @@index([retailerSkuId])
  @@index([sessionId])
}

model data_subscriptions {
  id        String             @id @default(cuid())
  userId    String
  plan      DaaSPlan           @default(BASIC)
  status    SubscriptionStatus @default(ACTIVE)
  apiKey    String             @unique
  rateLimit Int                @default(1000)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  users     users              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model merchant_contacts {
  id                 String                @id @default(cuid())
  merchantId         String
  firstName          String
  lastName           String
  email              String
  phone              String?
  marketingOptIn     Boolean               @default(false)
  communicationOptIn Boolean               @default(true)
  isAccountOwner     Boolean               @default(false)
  isActive           Boolean               @default(true)
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  roles              MerchantContactRole[] @default([])
  merchants          merchants             @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([email])
}

model retailer_feed_runs {
  id               String         @id @default(cuid())
  retailerId       String
  feedId           String
  status           FeedRunStatus
  errors           Json?
  rowCount         Int            @default(0)
  duration         Int?
  startedAt        DateTime       @default(now())
  completedAt      DateTime?
  primaryErrorCode String?
  quarantinedCount Int            @default(0)
  coercionCount    Int            @default(0)
  errorCodes       Json?
  indexedCount     Int            @default(0)
  rejectedCount    Int            @default(0)
  matchedCount     Int            @default(0)

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt        DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy        String?
  /// Reason for ignoring (e.g., 'bad_feed_data', 'duplicate_run', 'test_run')
  ignoredReason    String?

  retailer_feeds   retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
  @@index([ignoredAt])
}

model retailer_feed_test_runs {
  id               String         @id @default(cuid())
  retailerId       String
  feedId           String
  sampleSize       Int            @default(50)
  status           TestRunStatus
  recordsParsed    Int            @default(0)
  wouldIndex       Int            @default(0)
  wouldQuarantine  Int            @default(0)
  wouldReject      Int            @default(0)
  warningCount     Int            @default(0)
  errorCount       Int            @default(0)
  primaryErrorCode String?
  errorSamples     Json?
  coercionSummary  Json?
  duration         Int?
  startedAt        DateTime       @default(now())
  completedAt      DateTime?
  retailer_feeds   retailer_feeds @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@index([retailerId])
  @@index([feedId])
  @@index([startedAt])
}

model retailer_feeds {
  id                      String                    @id @default(cuid())
  retailerId              String
  name                    String?
  url                     String?
  username                String?
  password                String?
  scheduleMinutes         Int                       @default(60)
  status                  FeedStatus                @default(PENDING)
  feedHash                String?
  lastSuccessAt           DateTime?
  lastFailureAt           DateTime?
  lastError               String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  accessType              FeedAccessType            @default(URL)
  enabled                 Boolean                   @default(true)
  formatType              FeedFormatType            @default(GENERIC)
  lastRunAt               DateTime?
  primaryErrorCode        String?
  retailer_feed_runs      retailer_feed_runs[]
  retailer_feed_test_runs retailer_feed_test_runs[]
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_skus           retailer_skus[]
  feed_corrections        feed_corrections[]
  quarantined_records     quarantined_records[]

  @@index([retailerId])
  @@index([enabled])
}

model merchant_insights {
  id             String            @id @default(cuid())
  merchantId     String
  retailerSkuId  String?
  canonicalSkuId String?
  type           InsightType
  confidence     InsightConfidence
  title          String
  message        String
  merchantPrice  Decimal?          @db.Decimal(10, 2)
  marketMedian   Decimal?          @db.Decimal(10, 2)
  marketMin      Decimal?          @db.Decimal(10, 2)
  marketMax      Decimal?          @db.Decimal(10, 2)
  sellerCount    Int?
  priceDelta     Decimal?          @db.Decimal(10, 2)
  deltaPercent   Decimal?          @db.Decimal(5, 2)
  metadata       Json?
  isActive       Boolean           @default(true)
  dismissedAt    DateTime?
  dismissedUntil DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  merchants      merchants         @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  retailer_skus  retailer_skus?    @relation(fields: [retailerSkuId], references: [id])

  @@index([merchantId])
  @@index([isActive])
  @@index([type])
}

model merchant_invites {
  id             String           @id @default(cuid())
  merchantId     String
  email          String
  role           MerchantUserRole @default(MEMBER)
  inviteToken    String           @unique
  invitedById    String
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime         @default(now())
  merchants      merchants        @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_users merchant_users   @relation(fields: [invitedById], references: [id])

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([inviteToken])
}

model merchant_notification_prefs {
  id                 String    @id @default(cuid())
  merchantId         String    @unique
  fatalFeedErrors    Boolean   @default(true)
  nonFatalFeedIssues Boolean   @default(false)
  successfulUpdates  Boolean   @default(false)
  weeklyPulse        Boolean   @default(true)
  insightAlerts      Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  merchants          merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}

model retailer_skus {
  id                  String                @id @default(cuid())
  retailerId          String
  feedId              String?
  feedRunId           String?
  rawTitle            String
  rawDescription      String?
  rawPrice            Decimal               @db.Decimal(10, 2)
  rawUpc              String?
  rawSku              String?
  rawCaliber          String?
  rawGrain            String?
  rawCase             String?
  rawBulletType       String?
  rawBrand            String?
  rawPackSize         Int?
  rawInStock          Boolean               @default(true)
  rawUrl              String?
  rawImageUrl         String?
  canonicalSkuId      String?
  mappingConfidence   MappingConfidence     @default(NONE)
  needsReview         Boolean               @default(false)
  mappedAt            DateTime?
  mappedBy            String?
  parsedCaliber       String?
  parsedGrain         Int?
  parsedPackSize      Int?
  parsedBulletType    String?
  parsedBrand         String?
  parseConfidence     Decimal?              @db.Decimal(3, 2)
  retailerSkuHash     String?
  isActive            Boolean               @default(true)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  lastSeenAt          DateTime?
  missingCount        Int                   @default(0)
  productType         String?
  coercionsApplied    Json?
  merchant_insights   merchant_insights[]
  canonical_skus      canonical_skus?       @relation(fields: [canonicalSkuId], references: [id])
  retailers           retailers             @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  retailer_feeds      retailer_feeds?       @relation(fields: [feedId], references: [id])
  product_suggestions product_suggestions[]

  @@unique([retailerId, retailerSkuHash])
  @@index([canonicalSkuId])
  @@index([retailerId])
  @@index([feedId])
  @@index([isActive])
  @@index([needsReview])
}

model merchant_users {
  id                      String                    @id @default(cuid())
  merchantId              String
  email                   String
  passwordHash            String
  name                    String
  role                    MerchantUserRole          @default(MEMBER)
  emailVerified           Boolean                   @default(false)
  verifyToken             String?
  resetToken              String?
  resetTokenExp           DateTime?
  lastLoginAt             DateTime?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  merchant_invites        merchant_invites[]
  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, email])
  @@index([merchantId])
  @@index([email])
}

model merchants {
  id                          String                       @id @default(cuid())
  businessName                String
  websiteUrl                  String
  phone                       String?
  storeType                   StoreType                    @default(ONLINE_ONLY)
  status                      MerchantStatus               @default(PENDING)
  tier                        MerchantTier                 @default(FOUNDING)
  pixelApiKey                 String?                      @unique
  pixelEnabled                Boolean                      @default(false)
  shippingType                ShippingType                 @default(UNKNOWN)
  shippingFlat                Decimal?                     @db.Decimal(10, 2)
  shippingPerUnit             Decimal?                     @db.Decimal(10, 2)
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  contactFirstName            String
  contactLastName             String
  lastSubscriptionNotifyAt    DateTime?
  subscriptionExpiresAt       DateTime?
  subscriptionGraceDays       Int                          @default(7)
  subscriptionStatus          MerchantSubscriptionStatus   @default(ACTIVE)
  autoRenew                   Boolean                      @default(true)
  paymentMethod               MerchantPaymentMethod?
  stripeCustomerId            String?                      @unique
  stripeSubscriptionId        String?                      @unique
  click_events                click_events[]
  merchant_contacts           merchant_contacts[]
  merchant_insights           merchant_insights[]
  merchant_invites            merchant_invites[]
  merchant_notification_prefs merchant_notification_prefs?
  merchant_users              merchant_users[]
  pixel_events                pixel_events[]
  product_suggestions         product_suggestions[]
  merchant_retailers          merchant_retailers[]
  prices                      prices[]
  pricing_snapshots           pricing_snapshots[]
}

/// Explicit Merchant↔Retailer relationship.
/// Per Merchant-and-Retailer-Reference: One Merchant can administer many Retailers.
/// This replaces the deprecated retailers.merchantId optional field.
/// V1 Constraint: One Retailer can only belong to one Merchant (UNIQUE retailerId).
model merchant_retailers {
  id         String                 @id @default(cuid())
  merchantId String
  retailerId String                 @unique /// V1: Enforces 1 Retailer → 1 Merchant
  /// Status of the merchant-retailer relationship
  status     MerchantRetailerStatus @default(ACTIVE)
  createdAt  DateTime               @default(now())
  createdBy  String?
  updatedAt  DateTime               @updatedAt

  /// Listing status for consumer visibility (paid entitlement).
  /// Consumer visibility = retailers.visibilityStatus=ELIGIBLE AND listingStatus=LISTED AND status=ACTIVE
  listingStatus   MerchantRetailerListingStatus @default(UNLISTED)
  /// When retailer was listed (paid entitlement activated)
  listedAt        DateTime?
  /// Who listed the retailer (admin user ID or 'system' for auto)
  listedBy        String?
  /// When retailer was unlisted
  unlistedAt      DateTime?
  /// Who unlisted the retailer
  unlistedBy      String?
  /// Reason for unlisting (billing_delinquent, manual, policy_violation, etc.)
  unlistedReason  String?

  merchants               merchants                 @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  retailers               retailers                 @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchant_user_retailers merchant_user_retailers[]

  @@unique([merchantId, retailerId])
  @@index([merchantId])
  @@index([retailerId])
  @@index([status])
  @@index([listingStatus])
}

/// Per-retailer permissions for merchant users.
/// Per Merchant-and-Retailer-Reference: Permissions are per Retailer, explicit and auditable.
model merchant_user_retailers {
  id                 String               @id @default(cuid())
  merchantUserId     String
  merchantRetailerId String
  /// Role for this user on this specific retailer
  role               MerchantRetailerRole @default(VIEWER)
  createdAt          DateTime             @default(now())
  createdBy          String?
  updatedAt          DateTime             @updatedAt

  merchant_users     merchant_users     @relation(fields: [merchantUserId], references: [id], onDelete: Cascade)
  merchant_retailers merchant_retailers @relation(fields: [merchantRetailerId], references: [id], onDelete: Cascade)

  @@unique([merchantUserId, merchantRetailerId])
  @@index([merchantUserId])
  @@index([merchantRetailerId])
}

model execution_logs {
  id          String     @id @default(cuid())
  executionId String
  level       LogLevel   @default(INFO)
  event       String
  message     String
  metadata    Json?
  timestamp   DateTime   @default(now())
  executions  executions @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([event])
  @@index([executionId])
  @@index([level])
}

model executions {
  id             String           @id @default(cuid())
  sourceId       String
  status         ExecutionStatus  @default(PENDING)
  startedAt      DateTime         @default(now())
  completedAt    DateTime?
  duration       Int?
  itemsFound     Int              @default(0)
  itemsUpserted  Int              @default(0)
  errorMessage   String?

  /// ADR-015: Run ignore semantics for corrections
  /// When set, prices from this run are excluded from consumer queries
  ignoredAt      DateTime?
  /// Who ignored the run (admin user ID or 'system')
  ignoredBy      String?
  /// Reason for ignoring (e.g., 'bad_scrape_data', 'duplicate_run', 'test_run')
  ignoredReason  String?

  execution_logs execution_logs[]
  sources        sources          @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([ignoredAt])
}

model feed_corrections {
  id                  String               @id @default(cuid())
  retailerId          String
  feedId              String
  quarantinedRecordId String?
  recordRef           String
  field               String
  oldValue            String?
  newValue            String
  createdBy           String
  createdAt           DateTime             @default(now())
  retailer_feeds      retailer_feeds       @relation(fields: [feedId], references: [id], onDelete: Cascade)
  quarantined_records quarantined_records? @relation(fields: [quarantinedRecordId], references: [id])

  @@index([retailerId])
  @@index([feedId, recordRef])
  @@index([quarantinedRecordId])
}

model market_reports {
  id          String   @id @default(cuid())
  productId   String?
  category    String
  reportType  String
  data        Json
  generatedAt DateTime @default(now())
}

model pixel_events {
  id            String    @id @default(cuid())
  merchantId    String
  orderId       String
  orderValue    Decimal   @db.Decimal(10, 2)
  orderCurrency String    @default("USD")
  skuList       Json?
  clickEventId  String?
  attributedAt  DateTime?
  userAgent     String?
  ipHash        String?
  referrer      String?
  createdAt     DateTime  @default(now())
  merchants     merchants @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([merchantId])
  @@index([orderId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// Per ADR-015: Price history is append-only. Provenance fields enable corrections.
model prices {
  id                  String     @id @default(cuid())
  productId           String?
  retailerId          String
  merchantId          String?
  sourceId            String?
  price               Decimal    @db.Decimal(10, 2)
  currency            String     @default("USD")
  url                 String
  inStock             Boolean    @default(true)
  createdAt           DateTime   @default(now())
  /// ADR-015: When the price was observed at the source (not when written to DB)
  /// This is the canonical timestamp for correction matching and provenance
  observedAt          DateTime   @default(now())
  freeShippingMinimum Decimal?   @db.Decimal(10, 2)
  shippingCost        Decimal?   @db.Decimal(10, 2)
  shippingNotes       String?
  originalPrice       Decimal?   @db.Decimal(10, 2)
  priceType           PriceType?
  saleStartsAt        DateTime?
  saleEndsAt          DateTime?
  affiliateFeedRunId  String?
  priceSignatureHash  String?
  sourceProductId     String?

  /// ADR-015 Provenance: Type of ingestion run that created this price
  ingestionRunType IngestionRunType?
  /// ADR-015 Provenance: ID of the specific run (execution, affiliate_feed_run, merchant_feed_run)
  ingestionRunId   String?
  /// ADR-015 Provenance: Affiliate network ID if from affiliate feed
  affiliateId      String?

  affiliate_feed_runs affiliate_feed_runs? @relation(fields: [affiliateFeedRunId], references: [id])
  products            products?            @relation(fields: [productId], references: [id], onDelete: Cascade)
  retailers           retailers            @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  merchants           merchants?           @relation(fields: [merchantId], references: [id], onDelete: SetNull)
  sources             sources?             @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  source_products     source_products?     @relation(fields: [sourceProductId], references: [id])
  product_reports     product_reports[]

  @@index([inStock])
  @@index([productId])
  @@index([retailerId])
  @@index([sourceProductId])
  @@index([merchantId])
  @@index([sourceId])
  @@index([ingestionRunType])
  @@index([ingestionRunId])
  @@index([observedAt])
}

model pricing_snapshots {
  id             String         @id @default(cuid())
  canonicalSkuId String
  merchantId     String
  retailerId     String?
  sourceId       String?
  affiliateId    String?
  ingestionRunType IngestionRunType?
  ingestionRunId String?
  price          Decimal        @db.Decimal(10, 2)
  pricePerRound  Decimal?       @db.Decimal(10, 4)
  packSize       Int
  inStock        Boolean        @default(true)
  createdAt      DateTime       @default(now())
  /// ADR-015: When the price was observed at the source
  observedAt     DateTime       @default(now())
  canonical_skus canonical_skus @relation(fields: [canonicalSkuId], references: [id], onDelete: Cascade)
  retailers      retailers?     @relation(fields: [retailerId], references: [id], onDelete: SetNull)
  sources        sources?       @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  merchants      merchants      @relation(fields: [merchantId], references: [id])

  @@index([canonicalSkuId])
  @@index([createdAt])
  @@index([merchantId])
  @@index([retailerId])
  @@index([sourceId])
  @@index([ingestionRunType])
  @@index([ingestionRunId])
  @@index([observedAt])
  /// Composite index for retailer↔merchant alignment validation queries
  /// Supports: checking that retailerId maps to merchantId via merchant_retailers (v1 constraint)
  @@index([retailerId, merchantId], name: "pricing_snapshots_retailer_merchant_idx")
}

/// ADR-015: Corrections overlay for price history.
/// Corrections are explicit, auditable overlays that modify how facts are interpreted.
/// Facts (prices, pricing_snapshots) are never mutated; corrections change visibility/value at read time.
model price_corrections {
  id         String                    @id @default(cuid())

  /// Scope type determines what entity the correction applies to
  scopeType  PriceCorrectionScopeType
  /// ID of the scoped entity (productId, retailerId, merchantId, sourceId, affiliateId, or runId)
  scopeId    String

  /// Time window for the correction (observedAt must be in [startTs, endTs))
  startTs    DateTime
  endTs      DateTime

  /// What action to take
  action     PriceCorrectionAction

  /// Value for MULTIPLIER action (e.g., 0.9 for 10% discount correction)
  /// Must be NULL for IGNORE action
  value      Decimal?                  @db.Decimal(10, 4)

  /// Human-readable reason for the correction
  reason     String

  /// Audit fields for creation
  createdAt  DateTime                  @default(now())
  createdBy  String

  /// Soft-revoke fields - corrections are never deleted
  revokedAt  DateTime?
  revokedBy  String?
  revokeReason String?

  @@index([scopeType, scopeId])
  @@index([startTs, endTs])
  @@index([revokedAt])
  @@index([createdAt])
}

model product_reports {
  id          String           @id @default(cuid())
  productId   String
  userId      String?
  priceId     String?
  issueType   ProductIssueType
  description String
  status      ReportStatus     @default(PENDING)
  reviewedBy  String?
  reviewNotes String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  resolvedAt  DateTime?
  prices      prices?          @relation(fields: [priceId], references: [id])
  products    products         @relation(fields: [productId], references: [id], onDelete: Cascade)
  users       users?           @relation(fields: [userId], references: [id])
}

model product_suggestions {
  id             String                  @id @default(cuid())
  merchantId     String
  retailerSkuId  String?
  status         ProductSuggestionStatus @default(PENDING)
  suggestedName  String
  suggestedUpc   String?
  caliber        String
  grain          Int?
  packSize       Int?
  brand          String?
  bulletType     String?
  caseType       String?
  resolvedAt     DateTime?
  resolvedBy     String?
  rejectionNote  String?
  canonicalSkuId String?
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  canonical_skus canonical_skus?         @relation(fields: [canonicalSkuId], references: [id])
  merchants      merchants               @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  retailer_skus  retailer_skus?          @relation(fields: [retailerSkuId], references: [id])

  @@index([createdAt])
  @@index([merchantId])
  @@index([status])
}

model products {
  id                    String                 @id @default(cuid())
  name                  String
  description           String?
  category              String
  brand                 String?
  imageUrl              String?
  upc                   String?                @unique
  caliber               String?
  grainWeight           Int?
  caseMaterial          String?
  purpose               String?
  roundCount            Int?
  metadata              Json?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  embedding             Unsupported("vector")?
  barrelLengthReference Decimal?               @db.Decimal(4, 2)
  bulletType            BulletType?
  controlledExpansion   Boolean?
  dataConfidence        Decimal?               @db.Decimal(3, 2)
  dataSource            DataSource?            @default(UNKNOWN)
  factoryNew            Boolean?               @default(true)
  isSubsonic            Boolean?
  lowFlash              Boolean?
  lowRecoil             Boolean?
  matchGrade            Boolean?
  muzzleVelocityFps     Int?
  pressureRating        PressureRating?        @default(STANDARD)
  shortBarrelOptimized  Boolean?
  suppressorSafe        Boolean?
  alerts                alerts[]
  canonical_skus        canonical_skus[]
  prices                prices[]
  product_reports       product_reports[]
  watchlist_items       watchlist_items[]

  @@index([bulletType])
  @@index([caliber])
  @@index([isSubsonic])
  @@index([pressureRating])
  @@index([purpose])
}

model quarantined_records {
  id               String             @id @default(cuid())
  retailerId       String
  feedId           String
  runId            String?
  productType      String?
  matchKey         String
  rawData          Json
  parsedFields     Json?
  blockingErrors   Json
  status           QuarantineStatus   @default(QUARANTINED)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  feed_corrections feed_corrections[]
  retailer_feeds   retailer_feeds     @relation(fields: [feedId], references: [id], onDelete: Cascade)

  @@unique([feedId, matchKey])
  @@index([retailerId])
  @@index([feedId, status])
  @@index([status])
}

model retailers {
  id        String       @id @default(cuid())
  name      String
  website   String       @unique
  logoUrl   String?
  tier      RetailerTier @default(STANDARD)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  /// Consumer visibility state per ADR-005.
  /// ELIGIBLE = visible in consumer search, alerts, watchlists
  /// INELIGIBLE = hidden from consumers (policy, data quality, etc.)
  /// SUSPENDED = explicit block, under review
  visibilityStatus    RetailerVisibility @default(ELIGIBLE)
  visibilityReason    String?
  visibilityUpdatedAt DateTime?
  visibilityUpdatedBy String?

  prices             prices[]
  sources            sources[]
  subscriptions      subscriptions[]
  merchant_retailers merchant_retailers[]
  pricing_snapshots  pricing_snapshots[]
  retailer_feeds     retailer_feeds[]
  retailer_skus      retailer_skus[]

  @@index([visibilityStatus])
}

model source_product_presence {
  id                String          @id @default(cuid())
  sourceProductId   String          @unique
  lastSeenAt        DateTime
  lastSeenSuccessAt DateTime?
  updatedAt         DateTime        @updatedAt
  source_products   source_products @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  @@index([lastSeenSuccessAt])
}

model source_product_seen {
  id                  String              @id @default(cuid())
  runId               String
  sourceProductId     String
  createdAt           DateTime            @default(now())
  affiliate_feed_runs affiliate_feed_runs @relation(fields: [runId], references: [id], onDelete: Cascade)
  source_products     source_products     @relation(fields: [sourceProductId], references: [id], onDelete: Cascade)

  @@unique([runId, sourceProductId])
  @@index([runId])
}

model source_products {
  id                      String                    @id @default(cuid())
  sourceId                String
  identityType            SourceProductIdentityType
  identityValue           String
  title                   String
  url                     String
  imageUrl                String?
  sku                     String?
  upc                     String?
  urlHash                 String?
  normalizedUrl           String?
  impactItemId            String?
  createdByRunId          String?
  lastUpdatedByRunId      String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  prices                  prices[]
  source_product_presence source_product_presence?
  source_product_seen     source_product_seen[]
  sources                 sources                   @relation(fields: [sourceId], references: [id])

  @@unique([sourceId, identityType, identityValue])
  @@index([impactItemId])
  @@index([sku])
  @@index([sourceId])
}

model sources {
  id                        String            @id @default(cuid())
  name                      String
  url                       String
  type                      SourceType        @default(HTML)
  enabled                   Boolean           @default(true)
  interval                  Int               @default(3600)
  lastRunAt                 DateTime?
  paginationConfig          Json?
  affiliateNetwork          AffiliateNetwork?
  feedHash                  String?
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  retailerId                String
  affiliateAccountId        String?
  affiliateAccountName      String?
  affiliateAdvertiserId     String?
  affiliateCampaignId       String?
  affiliateProgramId        String?
  affiliateTrackingTemplate String?
  isDisplayPrimary          Boolean           @default(false)
  sourceKind                SourceKind        @default(DIRECT)
  affiliate_feeds           affiliate_feeds?
  executions                executions[]
  source_products           source_products[]
  prices                    prices[]
  pricing_snapshots         pricing_snapshots[]
  retailers                 retailers         @relation(fields: [retailerId], references: [id])

  @@index([retailerId], map: "sources_retailer_id_idx")
}

model subscriptions {
  id         String             @id @default(cuid())
  userId     String?
  retailerId String?
  type       SubscriptionType
  status     SubscriptionStatus @default(ACTIVE)
  startDate  DateTime           @default(now())
  endDate    DateTime?
  amount     Decimal            @db.Decimal(10, 2)
  currency   String             @default("USD")
  stripeId   String?            @unique
  retailers  retailers?         @relation(fields: [retailerId], references: [id], onDelete: Cascade)
  users      users?             @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model system_settings {
  key         String   @id @default(cuid())
  value       Json
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
}

model users {
  id                    String                  @id @default(cuid())
  email                 String                  @unique
  name                  String?
  image                 String?
  password              String?
  emailVerified         DateTime?
  tier                  UserTier                @default(FREE)
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  deletionRequestedAt   DateTime?
  deletionScheduledFor  DateTime?
  status                UserStatus              @default(ACTIVE)
  Account               Account[]
  Session               Session[]
  alerts                alerts[]
  data_subscriptions    data_subscriptions[]
  product_reports       product_reports[]
  subscriptions         subscriptions[]
  watchlist_collections watchlist_collections[]
  watchlist_items       watchlist_items[]
}

model watchlist_collections {
  id              String            @id @default(cuid())
  userId          String
  name            String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  users           users             @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchlist_items watchlist_items[]

  @@index([userId])
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// ADR-011A: Intent-Ready Saved Items (WatchlistItem Resolver Seam)
/// Supports SKU intent (v1) with schema-level preparation for future SEARCH intent.
/// See context/decisions/ADR-011A-Intent-Ready-Saved-Items.md for full specification.
model watchlist_items {
  id                      String                 @id @default(cuid())
  userId                  String
  productId               String?                /// Nullable for future SEARCH intent; v1 enforces non-null for SKU
  collectionId            String?
  createdAt               DateTime               @default(now())
  updatedAt               DateTime               @updatedAt

  /// ADR-011A: Intent-ready fields
  intentType              String                 @default("SKU") @map("intent_type")
  querySnapshot           Json?                  @map("query_snapshot")  /// For future SEARCH intent
  deletedAt               DateTime?              @map("deleted_at")      /// Soft delete timestamp

  /// Notification preferences (per ADR-011)
  notificationsEnabled    Boolean                @default(true)
  priceDropEnabled        Boolean                @default(true)
  backInStockEnabled      Boolean                @default(true)
  minDropPercent          Int                    @default(5)
  minDropAmount           Decimal                @default(5.0) @db.Decimal(10, 2)
  stockAlertCooldownHours Int                    @default(24)
  lastStockNotifiedAt     DateTime?
  lastPriceNotifiedAt     DateTime?

  /// Relations
  alerts                  alerts[]
  watchlist_collections   watchlist_collections? @relation(fields: [collectionId], references: [id])
  products                products?              @relation(fields: [productId], references: [id], onDelete: Cascade)
  users                   users                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Note: Uniqueness for active SKU items enforced by PARTIAL unique index in migration:
  // CREATE UNIQUE INDEX watchlist_items_sku_active_uniq ON watchlist_items (user_id, product_id)
  //   WHERE intent_type = 'SKU' AND deleted_at IS NULL AND product_id IS NOT NULL;
  // Prisma doesn't support partial indexes in schema, so this is managed via raw SQL migration.
  // See ADR-011A Section 19.1
  @@index([collectionId])
  @@index([productId])
  @@index([userId])
  @@index([deletedAt], map: "watchlist_items_deleted_at_idx")
  @@index([intentType], map: "watchlist_items_intent_type_idx")
}

enum AdType {
  DISPLAY
  SPONSORED_PRODUCT
  BANNER
}

enum AffiliateFeedRunStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

enum AffiliateFeedRunTrigger {
  SCHEDULED
  MANUAL
  MANUAL_PENDING
  ADMIN_TEST
  RETRY
}

enum AffiliateFeedStatus {
  DRAFT
  ENABLED
  PAUSED
  DISABLED
}

enum AffiliateNetwork {
  IMPACT
  AVANTLINK
  SHAREASALE
  CJ
  RAKUTEN
}

enum AlertRuleType {
  PRICE_DROP
  BACK_IN_STOCK
}

enum AlertType {
  PRICE_DROP
  BACK_IN_STOCK
  NEW_PRODUCT
}

enum BenchmarkConfidence {
  HIGH
  MEDIUM
  NONE
}

enum BenchmarkSource {
  INTERNAL
  EXTERNAL
  MIXED
}

enum BulletType {
  JHP
  HP
  BJHP
  XTP
  HST
  GDHP
  VMAX
  FMJ
  TMJ
  CMJ
  MC
  BALL
  SP
  JSP
  PSP
  RN
  FPRN
  FRANGIBLE
  AP
  TRACER
  BLANK
  WADCUTTER
  SWC
  LSWC
  BUCKSHOT
  BIRDSHOT
  SLUG
  OTHER
}

enum DaaSPlan {
  BASIC
  PROFESSIONAL
  ENTERPRISE
}

enum DataSource {
  MANUFACTURER
  RETAILER_FEED
  PARSED
  MANUAL
  AI_INFERRED
  UNKNOWN
}

enum MerchantContactRole {
  PRIMARY
  BILLING
  TECHNICAL
  MARKETING
  OTHER
}

enum MerchantPaymentMethod {
  STRIPE
  PURCHASE_ORDER
}

enum MerchantStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum MerchantSubscriptionStatus {
  ACTIVE
  EXPIRED
  SUSPENDED
  CANCELLED
}

enum MerchantTier {
  FOUNDING
  BASIC
  PRO
  ENTERPRISE
}

enum MerchantUserRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

/// Status of a merchant-retailer relationship
enum MerchantRetailerStatus {
  /// Active relationship, merchant can manage retailer
  ACTIVE
  /// Relationship pending approval
  PENDING
  /// Relationship suspended
  SUSPENDED
  /// Relationship terminated
  INACTIVE
}

/// Listing status for consumer visibility (paid entitlement).
/// Per Merchant-and-Retailer-Reference: Merchant pays to list each retailer.
enum MerchantRetailerListingStatus {
  /// Retailer is listed and visible to consumers (if also ELIGIBLE)
  LISTED
  /// Retailer is unlisted, hidden from consumers
  UNLISTED
}

/// Role for a merchant user on a specific retailer
enum MerchantRetailerRole {
  /// Full access to retailer management
  ADMIN
  /// Can edit feeds and data
  EDITOR
  /// Read-only access
  VIEWER
}

/// ADR-015: Type of ingestion run for price provenance tracking
enum IngestionRunType {
  /// Scraped from retailer website via executions
  SCRAPE
  /// From affiliate feed via affiliate_feed_runs
  AFFILIATE_FEED
  /// From merchant portal feed via merchant_feed_runs (legacy: dealer_feed_runs)
  MERCHANT_FEED
  /// Manual entry or import
  MANUAL
}

/// ADR-015: Scope types for price corrections
/// Precedence: PRODUCT > RETAILER > MERCHANT > SOURCE > AFFILIATE > FEED_RUN
enum PriceCorrectionScopeType {
  /// Correction applies to a specific product
  PRODUCT
  /// Correction applies to all prices from a retailer
  RETAILER
  /// Correction applies to all prices from a merchant
  MERCHANT
  /// Correction applies to all prices from a source
  SOURCE
  /// Correction applies to all prices from an affiliate
  AFFILIATE
  /// Correction applies to all prices from a specific feed run
  FEED_RUN
}

/// ADR-015: Actions for price corrections
enum PriceCorrectionAction {
  /// Exclude matching prices from all user-visible queries
  IGNORE
  /// Apply a multiplier to matching prices (visible_price = raw_price * value)
  MULTIPLIER
}

enum ExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum FeedAccessType {
  URL
  AUTH_URL
  FTP
  SFTP
  UPLOAD
}

enum FeedCompression {
  NONE
  GZIP
}

enum FeedFormat {
  CSV
}

enum FeedFormatType {
  GENERIC
  AMMOSEEK_V1
  GUNENGINE_V2
  IMPACT
}

enum FeedRunStatus {
  RUNNING
  SUCCESS
  WARNING
  FAILURE
  PENDING
  SKIPPED
}

enum FeedStatus {
  PENDING
  HEALTHY
  WARNING
  FAILED
}

enum FeedTransport {
  FTP
  SFTP
}

enum InsightConfidence {
  HIGH
  MEDIUM
}

enum InsightType {
  OVERPRICED
  UNDERPRICED
  STOCK_OPPORTUNITY
  ATTRIBUTE_GAP
}

enum LogLevel {
  INFO
  WARN
  ERROR
}

enum MappingConfidence {
  HIGH
  MEDIUM
  LOW
  NONE
}

enum PressureRating {
  STANDARD
  PLUS_P
  PLUS_P_PLUS
  NATO
  UNKNOWN
}

enum PriceType {
  REGULAR
  SALE
  CLEARANCE
}

enum ProductIssueType {
  INCORRECT_PRICE
  OUT_OF_STOCK
  INCORRECT_INFO
  BROKEN_LINK
  WRONG_PRODUCT
  SPAM
  OTHER
}

enum ProductSuggestionStatus {
  PENDING
  APPROVED
  REJECTED
  MERGED
}

enum QuarantineStatus {
  QUARANTINED
  RESOLVED
  DISMISSED
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum RetailerTier {
  STANDARD
  PREMIUM
}

/// Retailer visibility state for consumer-facing queries.
/// Per ADR-005: Eligibility applies to Retailer visibility only.
/// This is the authoritative source for consumer visibility filtering.
enum RetailerVisibility {
  /// Retailer is visible in consumer search, alerts, watchlists
  ELIGIBLE
  /// Retailer is hidden from consumers (policy, data quality, etc.)
  INELIGIBLE
  /// Retailer is suspended (explicit block, under review)
  SUSPENDED
}

enum ShippingType {
  FLAT
  PER_UNIT
  CALCULATED
  FREE
  UNKNOWN
}

enum SourceKind {
  DIRECT
  AFFILIATE_FEED
  OTHER
}

enum SourceProductIdentityType {
  IMPACT_ITEM_ID
  SKU
  URL_HASH
}

enum SourceType {
  HTML
  JS_RENDERED
  RSS
  JSON
  FEED_CSV
  FEED_XML
  FEED_JSON
}

enum StoreType {
  ONLINE_ONLY
  RETAIL_AND_ONLINE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum SubscriptionType {
  USER_PREMIUM
  RETAILER_PREMIUM
}

enum TestRunStatus {
  PASS
  WARN
  FAIL
}

enum UserStatus {
  ACTIVE
  PENDING_DELETION
  DELETED
}

enum UserTier {
  FREE
  PREMIUM
}
